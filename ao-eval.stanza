defpackage ao-eval :
   import core
   import math
   import collections
   import reader
   import geom
   import exp-parser
   import ao

defstruct Function :
  arity: Int
  apply: (List<Exp>) -> Node

defn Function (f:(Node) -> Node) :
  Function(1, fn (args:List<Exp>) : f(eval(args[0])))

defn Function (f:(Node, Node) -> Node) :
  Function(2, fn (args:List<Exp>) : f(eval(args[0]), eval(args[1])))

defn Function (f:(Node, Node, Node) -> Node) :
  Function(3, fn (args:List<Exp>) : f(eval(args[0]), eval(args[1]), eval(args[2])))

defn Function (f:(() -> Node) -> Node) :
  Function(1, fn (args:List<Exp>) : f({ eval(args[0]) }))

defn Function (f:(Node, () -> Node) -> Node) :
  Function(2, fn (args:List<Exp>) : f(eval(args[0]), { eval(args[1]) }))

defn Function (f:(Node, Node, () -> Node) -> Node) :
  Function(3, fn (args:List<Exp>) : f(eval(args[0]), eval(args[1]), { eval(args[2]) }))

defn Function (f:(Node, Node, Node, () -> Node) -> Node) :
  Function(4, fn (args:List<Exp>) : f(eval(args[0]), eval(args[1]), eval(args[2]), { eval(args[3]) }))

defstruct UndefinedFunctionException <: Exception :
  name: Symbol

defmethod print (o:OutputStream, e:UndefinedFunctionException) :
  print-all(o, ["Undefined function " name(e)])

defmethod print (o:OutputStream, f:Function) :
  print-all(o, ["FUN(" arity(f) ")"])

defn apply (name:Symbol, args:List<Exp>) -> Node :
  if key?(functions, name) :
    apply(functions[name])(args)
  else :
    throw(UndefinedFunctionException(name))

val bindings = HashTable<Symbol,(() -> Node)>()
val functions = HashTable<Symbol,Function>()

defstruct UndefinedBindingException <: Exception :
  name: Symbol

defmethod print (o:OutputStream, e:UndefinedBindingException) :
  print(o, "Undefined binding %_" % [name(e)])

defn lookup (n:Symbol) -> Node :
  if not key?(bindings, n) :
    throw(UndefinedBindingException(n))
  bindings[n]()

defstruct WrongNumberArgumentsException <: Exception :
  fun: Function
  num: Int

defmethod print (o:OutputStream, e:WrongNumberArgumentsException) :
  print(o, "Wrong number of args %_ for fun %_" % [num(e), arity(fun(e))])

defn apply (f:Function, args:List<Exp>) -> Node :
  if length(args) != arity(f) :
    throw(WrongNumberArgumentsException(f, length(args)))
  apply(f)(args)

defn eval (e:Exp) -> Node :
  match(e) :
    (e:ModOp) : eval(x(e)) % eval(y(e))
    (e:AndOp) : eval(x(e)) & eval(y(e))
    (e:OrOp) : eval(x(e)) | eval(y(e))
    (e:AddOp) : eval(x(e)) + eval(y(e))
    (e:SubOp) : eval(x(e)) - eval(y(e))
    (e:MulOp) : eval(x(e)) * eval(y(e))
    (e:DivOp) : eval(x(e)) / eval(y(e))
    (e:CallOp) : apply(name(f(e)), args(e))
    (e:Identifier) : lookup(name(e))
    (e:Number) : lit(value(e))
    (e:Integer) : lit(to-double(value(e)))

public defn eval-ao (s:String, to-mesh: (Tree) -> Mesh, default: Mesh) -> Mesh :
  try :
    val forms = read-all(s)
    val es = parse-exps(forms)
    if empty?(es) :
      default
    else :
      val e = es[0]
      val res = jit({ eval(e) })
      val m = to-mesh(res)
      m
   catch (e:Exception) :
     default

;;; AO BINDINGS

bindings[`pi] = { lit(3.1415) }
bindings[`x] = { fab-x() }
bindings[`y] = { fab-y() }
bindings[`z] = { fab-z() }
functions[`diff] = Function(fn (x:Node, y:Node): difference(x, y))
functions[`neg] = Function(fn (x:Node): negate(x))
functions[`min] = Function(fn (x:Node, y:Node): min(x, y))
functions[`max] = Function(fn (x:Node, y:Node): max(x, y))
functions[`sin] = Function(fn (x:Node): sin(x))
functions[`cos] = Function(fn (x:Node): cos(x))
functions[`tan] = Function(fn (x:Node): tan(x))
functions[`asin] = Function(fn (x:Node): asin(x))
functions[`acos] = Function(fn (x:Node): acos(x))
functions[`atan2] = Function(fn (x:Node, y:Node): atan2(x, y))
functions[`exp] = Function(exp)
functions[`sqr] = Function(square)
functions[`rect] = Function(rect)
functions[`circle] = Function(circle)
functions[`cube] = Function(cube)
functions[`sphere] = Function(sphere)
functions[`mov] = Function(move)
functions[`mov-x] = Function(move-x)
functions[`mov-y] = Function(move-y)
functions[`mov-z] = Function(move-x)
functions[`mag] = Function(scale)
functions[`mag1] = Function(scale1)
functions[`mag-x] = Function(scale-x)
functions[`mag-y] = Function(scale-y)
functions[`mag-z] = Function(scale-z)
;; functions[`rot] = Function(rotate)
functions[`rot-x] = Function(rotate-x)
functions[`rot-y] = Function(rotate-y)
functions[`rot-z] = Function(rotate-z)
functions[`reflect-x] = Function(reflect-x)
functions[`reflect-y] = Function(reflect-y)
functions[`reflect-z] = Function(reflect-z)
functions[`reflect-xy] = Function(reflect-xy)
functions[`reflect-xz] = Function(reflect-xz)
functions[`reflect-yz] = Function(reflect-yz)
functions[`offset] = Function(offset)
functions[`clearance] = Function(clearance)
functions[`blend] = Function(blend)
functions[`morph] = Function(morph)
functions[`extrude] = Function(extrude-z)
functions[`cyl] = Function(cylinder-z)
functions[`cone] = Function(cone-z)
functions[`pyr] = Function(pyramid-z)
functions[`torus] = Function(torus-z)
