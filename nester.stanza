defpackage nester :
  import core
  import math
  import collections
  import utils
  import geom
  import grid

public defstruct Pose3i :
  translation : V3i
  angle : Int

val gensyms = to-seq $ 0 to false

public defstruct Part <: Equalable :
  id : Int
  rot : Int
  image : Grid
  inside : Grid
  inside+1 : Grid
  outside : Grid
  boundary : Grid
  revolves : HashTable<Int, Part>

public defn Part (image:Grid, inside:Grid, inside+1:Grid, outside:Grid, boundary:Grid) :
  Part(next(gensyms), 0, image, inside, inside+1, outside, boundary, HashTable<Int, Part>())

defmethod equal? (a:Part, b:Part) -> True|False :
  image(a) == image(b)

defn ibbox (part:Part) : ibbox(outside(part))
defn idims (part:Part) : idims(outside(part))
defn dim (part:Part) : dim(outside(part))

public defstruct SuperPart <: Equalable :
  id : Int
  rots : Tuple<Part>

defmethod equal? (a:SuperPart, b:SuperPart) -> True|False :
  rots(a)[0] == rots(b)[0]

public defn SuperPart (id:Int, img:Grid) :
  val rots = seq(fn (rot) : Part(next(gensyms), rot, rotate(rot, img)), [0, 90, 180, 270])
  val urots = to-tuple $ unique $ rots
  println("SUPER-PART %_" % [idims(img)])
  ;; println-all(["UNIQUE ROTS " length(urots)])
  SuperPart(id, urots)

public defstruct Page :
  stock : Part
  result : Grid
  parts : Vector<KeyValue<Pose3i, Part>>

public defn Page (sdims:V3i, sdim:Float) :
  Page(Part(-2, 0, sdims, sdim), Grid(sdims + V3i(2, 2, 0), sdim), Vector<KeyValue<Pose3i, Part>>())

public defstruct PagePose3i :
  page : Int
  pose : Pose3i

public defstruct Arrangement :
  stock-dims : V3i
  stock-dim : Float
  unique-parts : HashTable<Grid, Part>
  poses : Vector<PagePose3i>
  pages : Vector<Page>

public defn Arrangement (sdims:V3i, sdim:Float) :
  val pages = Vector<Page>()
  add(pages, Page(sdims, sdim))
  Arrangement(sdims, sdim, HashTable<Grid, Part>(), Vector<PagePose3i>(), pages)

public defn uniquify (part:Part, assembly:Arrangement) :
  ;; println-all(["UNIQUE " id(part) " " key?(unique-parts(assembly), image(part))])
  set?(unique-parts(assembly), image(part), { part })

public defn uniquify (part:SuperPart, assembly:Arrangement) :
  SuperPart(id(part), to-tuple $ seq(uniquify{_, assembly}, rots(part)))

defn bbox (page:Page) -> Box3i :
  var res = neg-inf-box3i()
  for pos-part in parts(page) do :
    res = union(res, ibbox(value(pos-part)) + translation(key(pos-part)))
  res

defn revolve (a:Part, b:Part) -> Part :
  if key?(revolves(b), id(a)) :
    revolves(b)[id(a)]
  else :
    val res = Part(-1, 0, idims(a) + V3i(2 * x(idims(b)), 2 * y(idims(b)), 0) - V3i(2, 2, 0), dim(a))
    if trace?: println-all(["REVOLVE " idims(res)])
    if trace?: println-all(["INSIDE"])
    convolve-around(inside+1(res), inside+1(a), to-byte $ 0, inside(b))
    if trace?: println-all(["OUTSIDE"])
    invert(outside(res), inside+1(res))
    if trace?: dump(outside(res))
    if trace?: println-all(["BOUNDARY"])
    convolve-around(boundary(res), boundary(a), to-byte $ 0, boundary(b))
    if trace?: dump(boundary(res))
    revolves(b)[id(a)] = res
    res

val infi = 1 << 30

defn find-best (legal:Grid, bbox:Box3i, b:Part) -> [Int, V3i] :
  var best-area = infi
  var best-pos = V3i(-1, -1, -1)
  val trues = Todos()
  ;; println-all(["BBOX " bbox])
  for pos in true-indices(legal, trues) do :
    val new-bbox = union(bbox, ibbox(b) + pos)
    val area = area(dims(new-bbox))
    ;; println-all(["POS " pos " NEW-BBOX " new-bbox " AREA " area " LEGAL? " legal?(legal, xy(new-bbox))])
    if legal?(legal, xyz(xy(new-bbox))) and area < best-area :
      best-area = area
      best-pos = pos
  del(trues)
  [best-area, best-pos]

defn Part (id:Int, rot:Int, idims:V3i, dim:Float) :
  val bdims = idims + V3i(2, 2, 0)
  val image = Grid(idims, dim)
  val inside = Grid(bdims, dim)
  val outside = Grid(bdims, dim)
  val boundary = Grid(bdims, dim)
  val inside+1 = Grid(bdims, dim)
  Part(id, rot, image, inside, inside+1, outside, boundary, HashTable<Int, Part>())

defn Part (id:Int, rot:Int, img:Grid) :
  val res = Part(id, rot, idims(img), dim(img))
  fill(boundary(res), to-byte $ 0)
  if trace?: println-all(["PART " id "/" rot])
  copy(image(res), img)
  copy(inside(res), img, V3i(1, 1, 0))
  if trace?: println-all(["INSIDE"])
  if trace?: dump(inside(res))
  ;; println-all(["COPY"])
  ;; dump(outside(res))
  ;; println-all(["INVERT"])
  invert(outside(res), inside(res))
  ;; dump(outside(res))
  ;; println-all(["DILATE"])
  if trace?: println-all(["OUTSIDE"])
  if trace?: dump(outside(res))
  dilate(inside+1(res), inside(res), V3i(0, 0, 0))
  union(inside+1(res), inside+1(res), inside(res))
  if trace?: println-all(["INSIDE+1"])
  if trace?: dump(inside+1(res))
  intersect(boundary(res), outside(res), inside+1(res))
  if trace?: println-all(["BOUNDARY"])
  if trace?: dump(boundary(res))
  ;; println-all(["INTERSECT"])
  ;; dump(outside(res))
  res
  
defn clear (part:Part) :
  fill(inside(part), to-byte $ 0)
  fill(inside+1(part), to-byte $ 0)
  fill(outside(part), to-byte $ 0)
  fill(boundary(part), to-byte $ 0)

public defn add (assembly:Arrangement, new-super-part:SuperPart) -> True|False :
  label<True|False> return :
    for (page in pages(assembly), n in 0 to false) do :
      if add(assembly, page, new-super-part) :
        val parts = parts(page)
        add(poses(assembly), PagePose3i(n, key(parts[length(parts) - 1])))
        return(true)
    add(pages(assembly), Page(stock-dims(assembly), stock-dim(assembly)))
    add(assembly, pages(assembly)[length(pages(assembly)) - 1], new-super-part)

public defn add (assembly:Arrangement, page:Page, new-super-part:SuperPart) -> True|False :
  clear(stock(page))
  ;; val [best-pos, best-part] = 
  ;; if length(parts(assembly)) == 0 :
  ;;   [V3i(0, 0, 0), rots(new-super-part)[0]]
  ;; else :
  val legal = Grid(boundary(stock(page)))
  var best-area = infi
  var best-pos = V3i(-1, -1, -1)
  var best-part : Part
  for new-part in rots(new-super-part) do :
    fill(legal, to-byte $ 0)
    if length(parts(page)) == 0 :
      set-value(legal, V3i(0, 0), to-byte $ 1)
    else :
      for pose-part in parts(page) do :
        val part = value(pose-part)
        if trace?: println-all(["REVOLVE"])
        val res = revolve(part, new-part)
        val off = translation(key(pose-part)) - xyz(xy(idims(new-part)))
        if trace?: println-all(["UNION " off " DIMS " idims(res)])
        if trace?: dump(boundary(res))
        if trace?: println-all(["UNION RES"])
        union(boundary(stock(page)), boundary(stock(page)), boundary(res), off)
        if trace?: dump(boundary(stock(page)))
        if trace?: println-all(["INTERSECTION"])
        if trace?: dump(inside+1(res))
        if trace?: println-all(["INTERSECTION RES"])
        union(inside+1(stock(page)), inside+1(stock(page)), inside+1(res), off)
        if trace?: dump(inside+1(stock(page)))
      invert(outside(stock(page)), inside+1(stock(page)))
      intersect(legal, outside(stock(page)), boundary(stock(page)))
      fill(legal, to-byte $ 0,
           Box3i(V3i(0,                   y(idims(legal)) - y(idims(outside(new-part))) + 1, 0),
                 V3i(x(idims(legal)) - 1, y(idims(legal)) - 1,                               0)))
      fill(legal, to-byte $ 0,
           Box3i(V3i(x(idims(legal)) - x(idims(outside(new-part))) + 1, 0,                   0)
                 V3i(x(idims(legal)) - 1,                               y(idims(legal)) - 1, 0)))
      if trace?: println-all(["LEGAL"])
      if trace?: dump(legal)
    val [area, pos] = find-best(legal, bbox(page), new-part)
    if trace? : print-all(["ROT " rot(new-part) " AREA " area " POS " pos])
    if area < best-area :
      if trace?: println-all(["BEST"])
      best-area = area
      best-pos = pos
      best-part = new-part
    else :
      if trace?: println("")
  ;; [best-pos, best-part]
  val res = 
    if best-area < infi :
      println-all(["ADD " id(best-part) "/" rot(best-part) " AT " best-pos])
      add(parts(page), Pose3i(best-pos, rot(best-part)) => best-part)
      true
    else :
      if trace?: println-all(["FAILED TO ADD " id(new-super-part)])
      false
  fill(result(page), to-byte $ 0)
  for pose-part in parts(page) do :
    union(result(page), result(page), inside(value(pose-part)), translation(key(pose-part)))
  if trace?: println-all(["RESULT"])
  if trace?: dump(result(page))
  if trace?: println-all(["IDS " to-tuple $ seq(id, values(unique-parts(assembly)))])
  res

