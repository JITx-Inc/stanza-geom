defpackage ao :
  import core
  import math
  import collections
  import geom

extern store_new: () -> ptr<?>
extern store_delete: (ptr<?>) -> int
extern token_x: (ptr<?>) -> ptr<?>
extern token_y: (ptr<?>) -> ptr<?>
extern token_z: (ptr<?>) -> ptr<?>
extern token_const: (ptr<?>, float) -> ptr<?>
extern token_unary: (ptr<?>, int, ptr<?>) -> ptr<?>
extern token_binary: (ptr<?>, int, ptr<?>, ptr<?>) -> ptr<?>
extern opcode_enum: (ptr<?>) -> int
extern tree_new: (ptr<?>, ptr<?>) -> ptr<?>
extern tree_export_mesh: (ptr<?>, ptr<?>, float, float, float, float, float, float, float) -> ptr<?>
;; extern tree_render_mesh: (ptr<?>, ptr<ptr<float>>, float, float, float, float, float, float, float) -> int
extern tree_render_mesh: (ptr<?>, ptr<int>, ptr<ptr<float>>, ptr<int>, ptr<ptr<int>>, float, float, float, float, float, float, float) -> int
extern window_show_tree: (ptr<?>, ptr<?>, ptr<?>) -> ptr<?>
extern ao_run: () -> ptr<?>
extern ao_halt: () -> ptr<?>
extern printf: (ptr<?>, ? ...) -> int
extern free: (ptr<?>) -> int

public lostanza deftype Tree <: Geom :
  value: ptr<?>

defmethod print (o:OutputStream, t:Tree) :
  print-all(o, ["Tree()"])

public lostanza deftype Store :
  value: ptr<?>

public lostanza deftype FloField <: Geom :
  value: ptr<?>

defmethod print (o:OutputStream, t:FloField) :
  print-all(o, ["FloField()"])

public lostanza defn new-store () -> ref<Store> :
  return new Store{call-c store_new()}

public lostanza defn del (s:ref<Store>) -> ref<False> :
  call-c store_delete(s.value)
  return false

public lostanza defn new-tree (s:ref<Store>, t:ref<FloField>) -> ref<Tree> :
  return new Tree{call-c tree_new(s.value, t.value)}

public lostanza defn tree-export-mesh (t:ref<Tree>, filename:ref<String>, xmin:ref<Double>, ymin:ref<Double>, zmin:ref<Double>, xmax:ref<Double>, ymax:ref<Double>, zmax:ref<Double>, res:ref<Double>) -> ref<False> :
  call-c tree_export_mesh(t.value, addr!(filename.chars), xmin.value as float, xmax.value as float, ymin.value as float, ymax.value as float, zmin.value as float, zmax.value as float, res.value as float)
  return false

;; public lostanza deftype RenderMesh :
;;   length: int
;;   value: ptr<float>

public lostanza deftype RenderMesh :
  n-verts: int
  verts: ptr<float>
  n-tris: int
  tris: ptr<int>

public lostanza defn n-verts (m:ref<RenderMesh>) -> ref<Int> :
  return new Int{m.n-verts}

public lostanza defn get-vert-value (m:ref<RenderMesh>, i:ref<Int>) -> ref<Float> :
  return new Float{m.verts[i.value]}

public lostanza defn n-tris (m:ref<RenderMesh>) -> ref<Int> :
  return new Int{m.n-tris}

public lostanza defn get-vert-index (m:ref<RenderMesh>, i:ref<Int>) -> ref<Int> :
  return new Int{m.tris[i.value]}

defn to-mesh (rm:RenderMesh) -> Mesh :
  val tris = generate<V3i> :
    for ti in 0 to n-tris(rm) do :
      val toff = ti * 3
      yield(V3i(get-vert-index(rm, toff + 0), get-vert-index(rm, toff + 1), get-vert-index(rm, toff + 2)))
  val verts = generate<V3f> :
    for vi in 0 to n-tris(rm) do :
      val voff = vi * 3
      yield(V3f(get-vert-value(rm, voff + 0), get-vert-value(rm, voff + 1), get-vert-value(rm, voff + 2)))
  Mesh(to-tuple(verts), to-tuple(tris))

public lostanza defn tree-render-mesh (t:ref<Tree>, xmin:ref<Double>, ymin:ref<Double>, zmin:ref<Double>, xmax:ref<Double>, ymax:ref<Double>, zmax:ref<Double>, res:ref<Double>) -> ref<Mesh> :
  val out = new RenderMesh{0, 0L as ptr<float>, 0, 0L as ptr<int>}
  val len = call-c tree_render_mesh(t.value, addr!(out.n-verts), addr!(out.verts), addr!(out.n-tris), addr!(out.tris), xmin.value as float, xmax.value as float, ymin.value as float, ymax.value as float, zmin.value as float, zmax.value as float, res.value as float)
  val mesh = to-mesh(out)
  call-c free(out.verts)
  call-c free(out.tris)
  return mesh

public lostanza defn show (t:ref<Tree>, filename:ref<String>, name:ref<String>) -> ref<False> :
  call-c window_show_tree(addr!(filename.chars), addr!(name.chars), t.value)
  return false

public defn show (t:Tree) :
  show(t, "ao.stanza", "shape")

public lostanza defn ao-run () -> ref<False>  :
  call-c ao_run()
  return false

public lostanza defn ao-halt () -> ref<False> :
  call-c ao_halt()
  return false

public var *store* = new-store()
defn current-store () -> Store : *store*

public lostanza defn fab-x () -> ref<FloField> :
  return new FloField{call-c token_x(current-store().value)}
public lostanza defn fab-y () -> ref<FloField> :
  return new FloField{call-c token_y(current-store().value)}
public lostanza defn fab-z () -> ref<FloField> :
  return new FloField{call-c token_z(current-store().value)}
public lostanza defn lit (f:ref<Float>) -> ref<FloField> :
  return new FloField{call-c token_const(current-store().value, f.value)}
public lostanza defn lit (f:ref<Double>) -> ref<FloField> :
  return lit(to-float(f))
public lostanza defn unary (op:ref<Int>, t:ref<FloField>) -> ref<FloField> :
  return new FloField{call-c token_unary(current-store().value, op.value, t.value)}
public lostanza defn binary (op:ref<Int>, t1:ref<FloField>, t2:ref<FloField>) -> ref<FloField> :
  return new FloField{call-c token_binary(current-store().value, op.value, t1.value, t2.value)}
public lostanza defn op (name:ref<String>) -> ref<Int> :
  return new Int{call-c opcode_enum(addr!(name.chars))}

public defn modulo (x:FloField, y:FloField) -> FloField : binary(op("mod"), x, y)
public defn times (x:FloField, y:FloField) -> FloField : binary(op("mul"), x, y)
public defn nan-fill (x:FloField, y:FloField) -> FloField : binary(op("nan-fill"), x, y)
public defn min (x:FloField, y:FloField) -> FloField : binary(op("min"), x, y)
public defn max (x:FloField, y:FloField) -> FloField : binary(op("max"), x, y)
public defn divide (x:FloField, y:FloField) -> FloField : binary(op("div"), x, y)
public defn plus (x:FloField, y:FloField) -> FloField : binary(op("add"), x, y)
public defn minus (x:FloField, y:FloField) -> FloField : binary(op("sub"), x, y)
public defn atan2 (x:FloField, y:FloField) -> FloField : binary(op("atan2"), x, y)
public defn sqrt (x:FloField) -> FloField : unary(op("sqrt"), x)
public defn sqr (x:FloField) -> FloField : unary(op("square"), x)
public defn abs (x:FloField) -> FloField : unary(op("abs"), x)
public defn sin (x:FloField) -> FloField : unary(op("sin"), x)
public defn cos (x:FloField) -> FloField : unary(op("cos"), x)
public defn tan (x:FloField) -> FloField : unary(op("tan"), x)
public defn asin (x:FloField) -> FloField : unary(op("asin"), x)
public defn acos (x:FloField) -> FloField : unary(op("acos"), x)
public defn exp (x:FloField) -> FloField : unary(op("exp"), x)
public defn negate (x:FloField) -> FloField : unary(op("neg"), x)

public defn clamp (n:FloField, mn:FloField, mx:FloField) -> FloField :
  min(mx, max(mn, n))

public val pi = 3.1414

public deftype VecField
public defmulti x (v:VecField) -> FloField
public defmulti y (v:VecField) -> FloField
public defmulti z (v:VecField) -> FloField

public defn VecField (x:FloField, y:FloField, z:FloField) :
  new VecField :
    defmethod x (this) : x
    defmethod y (this) : y
    defmethod z (this) : z

public defn VecField (n:FloField) -> VecField :
  VecField(n, n, n)

defmethod print (o:OutputStream, v:VecField) :
  print(o, "VecField(%_, %_, %_)" % [x(v), y(v), z(v)])

public deftype V2n <: VecField

public defn V2n (x:FloField, y:FloField) :
  new V2n :
    defmethod x (this) : x
    defmethod y (this) : y
    defmethod z (this) : lit(0.0)

defmethod print (o:OutputStream, v:V2n) :
  print(o, "V2n(%_, %_)" % [x(v), y(v)])

public defn V2n (n:FloField) -> V2n :
  V2n(n, n)

public defn xy (v:VecField) -> V2n :
  V2n(x(v), y(v))

public defn yz (v:VecField) -> V2n :
  V2n(y(v), z(v))

public defn xz (v:VecField) -> V2n :
  V2n(x(v), z(v))

public defn abs (a:VecField) -> VecField :
  VecField(abs(x(a)), abs(y(a)), abs(z(a)))

public defn max (a:VecField, b:FloField) -> VecField :
  VecField(max(x(a), b), max(y(a), b), max(z(a), b))

public defn plus (a:VecField, b:VecField) -> VecField :
  VecField(x(a) + x(b), y(a) + y(b), z(a) + z(b))

public defn minus (a:VecField, b:VecField) -> VecField :
  VecField(x(a) - x(b), y(a) - y(b), z(a) - z(b))

public defn negate (a:VecField) -> VecField :
  VecField((- x(a)), (- y(a)), (- z(a)))

public defn times (s:FloField, v:VecField) -> VecField :
  VecField(s * x(v), s * y(v), s * z(v))

public defn times (a:VecField, b:VecField) -> VecField :
  VecField(x(a) * x(b), y(a) * y(b), z(a) * z(b))

public defn dot (a:VecField, b:VecField) -> FloField :
  x(a) * x(b) + y(a) * y(b) + z(a) * z(b)

public defn len (v:VecField) -> FloField :
  sqrt(dot(v, v))

public defn normalize (v:VecField) -> VecField :
  v / len(v)

public defn divide (a:VecField, b:FloField) -> VecField :
  VecField(x(a) / b, y(a) / b, z(a) / b)

public defn divide (a:VecField, b:VecField) -> VecField :
  VecField(x(a) / x(b), y(a) / y(b), z(a) / z(b))

public defn modulo (a:VecField, b:VecField) -> VecField :
  VecField(y(a) * z(b) - z(a) * y(b),
      z(a) * x(b) - x(a) * z(b),
      x(a) * y(b) - y(a) * x(b))

var *pt* = VecField(fab-x(), fab-y(), fab-z())

public defn pt () -> VecField : *pt*
public defn x () -> FloField : x(pt())
public defn y () -> FloField : y(pt())
public defn z () -> FloField : z(pt())

public defn with-xyz (npt:VecField, f:()->FloField) -> FloField :
  let-var *pt* = npt :
    f()

public defn with-xyz (nx:FloField, ny:FloField, nz:FloField, f:()->FloField) -> FloField :
  with-xyz(VecField(nx, ny, nz), f)

public defn move (dp:VecField, f:()->FloField) -> FloField :
  with-xyz(pt() - dp, f)

;; public defn move (dx:FloField, dy:FloField, f:()->FloField) -> FloField :
;;   move(dx, dy, lit(0.0), f)

public defn move-x (dx:FloField, f:() -> FloField) -> FloField : move(VecField(dx, lit(0.0), lit(0.0)), f)
public defn move-y (dy:FloField, f:() -> FloField) -> FloField : move(VecField(lit(0.0), dy, lit(0.0)), f)
public defn move-z (dz:FloField, f:() -> FloField) -> FloField : move(VecField(lit(0.0), lit(0.0), dz), f)

public defn rotate-x (a:FloField, s:()->FloField) -> FloField :
  val [ca, sa] = [cos(a), sin(a)]
  with-xyz(x(), ca * y() + sa * z(), (- sa) * y() + ca * z(), s)

public defn rotate-y (a:FloField, s:()->FloField) -> FloField :
  val [ca, sa] = [cos(a), sin(a)]
  with-xyz(ca * x() + sa * z(), y(), (- sa) * x() + ca * z(), s)

public defn rotate-z (a:FloField, s:()->FloField) -> FloField :
  val [ca, sa] = [cos(a), sin(a)]
  with-xyz(ca * x() + sa * y(), (- sa) * x() + ca * y(), z(), s)

public defn reflect-x (s:()->FloField) -> FloField :
  with-xyz((- x()), y(), z(), s)

public defn reflect-y (s:()->FloField) -> FloField :
  with-xyz(x(), (- y()), z(), s)

public defn reflect-z (s:()->FloField) -> FloField :
  with-xyz(x(), y(), (- z()), s)

public defn reflect-xy (s:()->FloField) -> FloField :
  with-xyz(y(), x(), z(), s)

public defn reflect-xz (s:()->FloField) -> FloField :
  with-xyz(z(), y(), x(), s)

public defn reflect-yz (s:()->FloField) -> FloField :
  with-xyz(x(), z(), y(), s)

public defn scale (fac:VecField, s:()->FloField) -> FloField :
  with-xyz(pt() / fac, s)

public defn scale1 (sa:FloField, s:()->FloField) -> FloField :
  with-xyz(pt() / sa, s)

public defn scale-x (sx:FloField, s:()->FloField) -> FloField :
  with-xyz(x() / sx, y(), z(), s)

public defn scale-y (sy:FloField, s:()->FloField) -> FloField :
  with-xyz(x(), y() / sy, z(), s)

public defn scale-z (sz:FloField, s:()->FloField) -> FloField :
  with-xyz(x(), y(), z() / sz, s)

defn shear-x-y (ymin:FloField, ymax:FloField, dx0:FloField, dx1:FloField, s:()->FloField) -> FloField :
  val f = (y() - ymin) / (ymax - y())
  with-xyz(x() - dx0 * (lit(1.0) - f) - dx1 * f, y(), z(), s)

public defn shear-x-y (h:FloField, dx0:FloField, dx1:FloField, s:()->FloField) -> FloField :
  shear-x-y(dim-min(h), dim-max(h), dx0, dx1, s)

defn taper-x-y (ymin:FloField, ymax:FloField, s0:FloField, s1:FloField, s:()->FloField) -> FloField :
  val dy = ymax - ymin
  val ds = s1 - s0
  val sc = dy / ((s1 * (y() - ymin)) - (s0 * (y() - ymax)))
  with-xyz(x() * sc, y(), z(), s)

defn taper-xy-z (zmin:FloField, zmax:FloField, s0:FloField, s1:FloField, s:()->FloField) -> FloField :
  val dz = zmax - zmin
  val sc = dz / ((s1 * (z() - zmin)) - (s0 * (z() - zmax)))
  with-xyz(x() * sc, y() * sc, z(), s)

public defn taper-xy-z (h:FloField, s0:FloField, s1:FloField, s:()->FloField) -> FloField :
  taper-xy-z(dim-min(h), dim-max(h), s0, s1, s)

public defn revolve-y (s:()->FloField) -> FloField :
  with-xyz(sqrt(sqr(x()) + sqr(z())), y(), z(), s)

public defn revolve-x (s:()->FloField) -> FloField :
  with-xyz(x(), sqrt(sqr(y()) + sqr(z())), z(), s)

public defn circle (d:FloField) -> FloField :
  len(xy(pt())) - (d * lit(0.5))

;; public defn circle (x:FloField, y:FloField, r:FloField) -> FloField :
;;   move(x, y, {circle(r)})

public defn sphere (d:FloField) -> FloField :
  len(pt()) - (d * lit(0.5))

;; public defn sphere (x:FloField, y:FloField, z:FloField, r:FloField) -> FloField :
;;   move(x, y, z, {circle(r)})

public defn bit-or (a:FloField, b:FloField) -> FloField :
  min(a, b)

public defn union (args:Seqable<FloField>) -> FloField :
  reduce(bit-or, args)

public defn bit-and (a:FloField, b:FloField) -> FloField :
  max(a, b)

public defn intersection (args:Seqable<FloField>) -> FloField :
  reduce(bit-and, args)

public defn difference (a:FloField, b:FloField) -> FloField :
  max(a, (- b))

public defn difference (a:FloField, args:Seqable<FloField>) -> FloField :
  difference(a, union(args))

public defn offset (s:FloField, o:FloField) -> FloField : s - o
  
public defn clearance (a:FloField, b:FloField, o:FloField) -> FloField :
  max(a, (- offset(b, o)))
  
public defn shell (s:FloField, o:FloField) -> FloField :
  clearance(s, s, o)
  
public defn blend (a:FloField, b:FloField, m:FloField) -> FloField :
  val joint = a | b
  val fillet = sqrt(abs(a) + sqrt(abs(b))) - m
  joint | fillet
  
public defn morph (a:FloField, b:FloField, m:FloField) -> FloField :
  a * (lit(1.0) - m) + b * m
  
defn rect (xmin:FloField, ymin:FloField, xmax:FloField, ymax:FloField) -> FloField :
  max(max(xmin - x(), x() - xmax), max(ymin - y(), y() - ymax))

public defn dim-min (d:FloField) -> FloField : d * lit(-0.5)
public defn dim-max (d:FloField) -> FloField : d * lit(0.5)

public defn rect (w:FloField, h:FloField) -> FloField :
  rect(dim-min(w), dim-min(h), dim-max(w), dim-max(h))

public defn square (d:FloField) -> FloField :
  rect(d, d)

public defn edge (v0:V2n, v1:V2n) -> FloField :
  (y(v1) - y(v0)) * (x() - x(v0)) - (x(v1) - x(v0)) * (y() - y(v0))

public defn convex (pts:Tuple<V2n>) -> FloField :
  val edges = for i in 0 to length(pts) seq :
                edge(pts[i], pts[(i + 1) % length(pts)])
  reduce(fn (a:FloField, b:FloField): max(a, b), edges)

public defn to-field (v:V3f) -> VecField :
  VecField(lit(x(v)), lit(y(v)), lit(z(v)))

public defn to-field2 (v:V3f) -> V2n :
  V2n(lit(x(v)), lit(y(v)))

public defn to-field2 (segment:[V3f, V3f]) -> [V2n, V2n] :
  [to-field2(segment[0]), to-field2(segment[1])]

public defn to-field (segment:[V3f, V3f]) -> [VecField, VecField] :
  [to-field(segment[0]), to-field(segment[1])]

public defn to-field2 (contour:Contour) -> Seq<[V2n, V2n]> :
  for s in segments(contour) seq : to-field2(s)

public defn to-field (p:PolyLine) -> Seq<[VecField, VecField]> :
  for s in segments(p) seq : to-field(s)

public defn to-field2 (p:PolyLine) -> Seq<[V2n, V2n]> :
  for s in segments(p) seq : to-field2(s)

public defn to-field2 (m:Mesh) -> FloField :
  val verts = vertices(m)
  union(for face in faces(m) seq :
          triangle(to-field2(verts[face[0]]), to-field2(verts[face[1]]), to-field2(verts[face[2]])))

public defn triangle (a:V2n, b:V2n, c:V2n) -> FloField :
  convex([a, b, c])

defn extrude-z (zmin:FloField, zmax:FloField, shape:FloField) -> FloField :
   max(shape, max(zmin - z(), z() - zmax))

public defn extrude-z (h:FloField, shape:FloField) -> FloField :
  extrude-z(dim-min(h), dim-max(h), shape)

;;; DEPRECATE
defn cube (xmin:FloField, ymin:FloField, zmin:FloField, xmax:FloField, ymax:FloField, zmax:FloField) -> FloField :
  extrude-z(zmin, zmax, rect(xmin, ymin, xmax, ymax))

;;; DEPRECATE
defn cube (w:FloField, h:FloField, d:FloField) -> FloField :
  cube(dim-min(w), dim-min(h), dim-min(d), dim-max(w), dim-max(h), dim-max(d))

;;; DEPRECATE
public defn cube (d:FloField) -> FloField :
  cube(d, d, d)

public defn box (dims:VecField) -> FloField :
  val d = abs(pt()) - lit(0.5) * dims
  min(max(x(d),max(y(d),z(d))),lit(0.0)) + len(max(d,lit(0.0)))

public defn round-box (dims:VecField, r:FloField) -> FloField :
  len(max(abs(pt()) - lit(0.5) * dims, lit(0.0))) - r

public defn cylinder-z (d:FloField, h:FloField) -> FloField :
  extrude-z(h, circle(d))

public defn capsule (a:VecField, b:VecField, r:FloField) -> FloField :
  val p = match(a): ((v:V2n) : xy(pt()) (v:VecField) : pt())
  val pa = p - a
  val ba = b - a
  val h  = clamp(dot(pa, ba) / dot(ba, ba), lit(0.0), lit(1.0))
  len(pa - h * ba) - r

public defn thicken (segments:Seqable<[VecField, VecField]>, r:FloField) -> FloField :
  val caps = for [v0, v1] in segments seq : capsule(v0, v1, r)
  reduce(fn (a:FloField, b:FloField): a | b, caps)

public defn capsule-z (d:FloField, h:FloField) -> FloField :
  val r = lit(0.5) * h
  cylinder-z(d, h) | move-z(r, { sphere(d) }) | move-z((- r), { sphere(d) })

public defn cone-z (d:FloField, h:FloField) -> FloField :
  taper-xy-z(h, lit(1.0), lit(0.0), {cylinder-z(d, h)})

public defn pyramid-z (d:FloField, h:FloField) -> FloField :
  taper-xy-z(h, lit(0.0), lit(1.0), {extrude-z(h, rect(d, d))})

public defn torus-z (D:FloField, d:FloField) -> FloField :
  len(V2n((D * lit(0.5)) - len(xy(pt())), z())) - (d * lit(0.5))

public defn jit (f:() -> Geom) -> Geom :
  let-var *store* = new-store() :
    let-var *pt* = VecField(fab-x(), fab-y(), fab-z()) :
      val g = f()
      val res = 
        match(g) :
          (root:FloField) :
            new-tree(*store*, root)
          (geom) : geom
      del(*store*)
      res

