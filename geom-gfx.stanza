;; See license.txt for details about licensing.

defpackage geom-gfx:
  import core
  import math
  import collections
  import geom
  import gl
  import gfx
  import font

extern glLoadMatrixf: (ptr<float>) -> int
extern glMultMatrixf: (ptr<float>) -> int

public defn gl-color3 (v:V3f) : gl-color3f(x(v), y(v), z(v))

public defn gl-color4 (v:V4f) : gl-color4f(x(v), y(v), z(v), a(v))

public defn gl-vertex3 (v:V3f) : gl-vertex3f(x(v), y(v), z(v))

public defn gl-vertex2 (v:V3f) : gl-vertex2f(x(v), y(v))

public defn gl-translate3 (v:V3f) : gl-translatef(x(v), y(v), z(v))

public defn gl-translate2 (v:V3f) : gl-translatef(x(v), y(v), 0.0f)

public defmulti render (g:Geom) -> False

public defn compile (g:Geom) -> DisplayList :
  val dl = gl-gen-list()
  gl-new-list(dl, GL-COMPILE)
  render(g)
  gl-end-list(dl)
  dl

defmethod render (p:V3f) -> False :
  gl-begin(GL-POINTS)
  gl-vertex3(p)
  gl-end()

defmethod render (box:Box) -> False :
  gl-begin(GL-LINE-LOOP)
  gl-vertex3(lo(box))
  gl-vertex3(hi(box))
  gl-end()

defmethod render (msg:Msg) -> False :
  draw-text(2.0f, 2.0f, *font*, value(msg))

defmethod render (poly:PolyLine) -> False :
  for s in strokes(poly) do :
    gl-begin(GL-LINE-STRIP)
    for p in s do :
      gl-vertex3(p)
    gl-end()

defmethod render (contour:Contour) -> False :
  gl-begin(GL-LINE-LOOP)
  for p in points(contour) do :
    gl-vertex2(p)
  gl-end()

defmethod render (poly:Polygon) -> False :
  for c in contours(poly) do :
    render(c)

defmethod render (mesh:Mesh) -> False :
  ;; for t in faces(mesh) do :
  ;;   gl-begin(GL-TRIANGLES)
  ;;   gl-vertex3(vertices(mesh)[x(t)])
  ;;   gl-vertex3(vertices(mesh)[y(t)])
  ;;   gl-vertex3(vertices(mesh)[z(t)])
  ;;   gl-end()
  ;; gl-push-attrib(GL-CURRENT-BIT)
  ;; gl-color3f(1.0f, 0.5f, 0.5f)
  for t in faces(mesh) do :
    gl-begin(GL-LINE-LOOP)
    gl-vertex3(vertices(mesh)[x(t)])
    gl-vertex3(vertices(mesh)[y(t)])
    gl-vertex3(vertices(mesh)[z(t)])
    gl-end()
  ;; gl-pop-attrib()

public lostanza defn gl-load-matrix (m:ref<Mat44>) -> ref<False> :
  call-c glLoadMatrixf(addr!(m.m00))
  return false

public lostanza defn gl-mult-matrix (m:ref<Mat44>) -> ref<False> :
  call-c glMultMatrixf(addr!(m.m00))
  return false

public defn render-begin (t:Transformation) :
  gl-matrix-mode(GL-PROJECTION)
  gl-translate2(mov(t))
  gl-matrix-mode(GL-MODELVIEW)
  gl-push-matrix()
  gl-mult-matrix(rot(ball(t)))
  gl-scalef(mag(t), mag(t), mag(t))

public defn render-end (t:Transformation) :
  gl-pop-matrix()

