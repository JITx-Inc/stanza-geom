;; See license.txt for details about licensing.

defpackage geom:
  import core
  import math
  import collections
  import utils

val @doc-geom = "## GEOM -- explicit geometry and support data types"

public defn ensure-index-in-bounds (i:Int, n:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if i < 0 or i >= n :
      fatal("Index (%_) out of bounds." % [i])

public deftype Geom

public defstruct Msg <: Geom :
  value : String

;;; PIXELS

public defstruct Pixels <: Geom :
  idims: V3i
  dim: Float
  data: ByteArray

public defn index (g:Pixels, i:Int, j:Int, k:Int) -> Int :
  (k * idims(g)[0] * idims(g)[1]) + j * idims(g)[0] + i

public defn index (g:Pixels, pos:V3i) -> Int :
  index(g, x(pos), y(pos), z(pos))

public defn get (g:Pixels, i:Int, j:Int, k:Int) -> Byte :
  data(g)[index(g, i, j, k)]

public defn get (g:Pixels, pos:V3i) -> Byte :
  data(g)[index(g, pos)]

public defn set (g:Pixels, pos:V3i, v:Byte) -> False :
  data(g)[index(g, pos)] = v

;;; VECS

public lostanza deftype Vf <: Array<Float> & Geom :
  length: long
  elts:   float ...

public lostanza defn Vf (n:ref<Int>, x:ref<Float>) -> ref<Vf> :
  core/ensure-non-negative-length(n)
  val l = n.value
  val a = new Vf{l}
  val c = x.value
  for (var i:long = 0, i < l, i = i + 1) :
    a.elts[i] = c
  return a

;; USE PRIMARRAYS

public defn Vf (n:Int) -> Vf :
  Vf(n, 0.0f)

lostanza defn vf-get (v:ref<Vf>, i:ref<Int>) -> ref<Float> :
  ensure-index-in-bounds(i, length(v))
  return new Float{v.elts[i.value]}
  
lostanza defn vf-set (v:ref<Vf>, i:ref<Int>, x:ref<Float>) -> ref<False> :
  ensure-index-in-bounds(i, length(v))
  v.elts[i.value] = x.value
  return false
  
lostanza defn vf-length (v:ref<Vf>) -> ref<Int> :
  return new Int{v.length as int}
  
defmethod get (a:Vf, i:Int) -> Float : vf-get(a, i)
defmethod set (a:Vf, i:Int, c:Float) -> False : vf-set(a, i, c)
defmethod length (a:Vf) -> Int : vf-length(a)

defmethod print (o:OutputStream, v:Vf) :
  print-all(o, ["Vf(" length(v) ")"])

public lostanza deftype Vi <: Array<Int> & Geom :
  length: long
  elts:   int ...

public lostanza defn Vi (n:ref<Int>, x:ref<Int>) -> ref<Vi> :
  core/ensure-non-negative-length(n)
  val l = n.value
  val a = new Vi{l}
  val c = x.value
  for (var i:long = 0, i < l, i = i + 1) :
    a.elts[i] = c
  return a

public defn Vi (n:Int) -> Vi :
  Vi(n, 0)

lostanza defn vi-get (v:ref<Vi>, i:ref<Int>) -> ref<Int> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, length(v))
  return new Int{v.elts[i.value]}
  
lostanza defn vi-set (v:ref<Vi>, i:ref<Int>, x:ref<Int>) -> ref<False> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, length(v))
  v.elts[i.value] = x.value
  return false
  
lostanza defn vi-length (v:ref<Vi>) -> ref<Int> :
  return new Int{v.length as int}
  
defmethod get (a:Vi, i:Int) -> Int : vi-get(a, i)
defmethod set (a:Vi, i:Int, c:Int) -> False : vi-set(a, i, c)
defmethod length (a:Vi) -> Int : vi-length(a)

defmethod print (o:OutputStream, v:Vi) :
  print-all(o, ["Vi(" length(v) ")"])

public lostanza deftype Vb <: Array<Byte> & Geom :
  length: long
  elts:   byte ...

public lostanza defn Vb (n:ref<Int>, x:ref<Byte>) -> ref<Vb> :
  core/ensure-non-negative-length(n)
  val l = n.value
  val a = new Vb{l}
  val c = x.value
  for (var i:long = 0, i < l, i = i + 1) :
    a.elts[i] = c
  return a

public defn Vb (n:Int) -> Vb :
  Vb(n, to-byte $ 0)

lostanza defn vi-get (v:ref<Vb>, i:ref<Int>) -> ref<Byte> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, length(v))
  return new Byte{v.elts[i.value]}
  
lostanza defn vi-set (v:ref<Vb>, i:ref<Int>, x:ref<Byte>) -> ref<False> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, length(v))
  v.elts[i.value] = x.value
  return false
  
lostanza defn vi-length (v:ref<Vb>) -> ref<Int> :
  return new Int{v.length as int}
  
defmethod get (a:Vb, i:Int) -> Byte : vi-get(a, i)
defmethod set (a:Vb, i:Int, c:Byte) -> False : vi-set(a, i, c)
defmethod length (a:Vb) -> Int : vi-length(a)

defmethod print (o:OutputStream, v:Vb) :
  print-all(o, ["Vb(" length(v) ")"])

;;; V3x

defn round (x:Int) : x
defn sqrt (x:Int) : to-int(round(sqrt(to-float(x))))

val @doc-vx = "2/3 DIM VECTORS -- ponts and dimensions"

#for (Prim in [Int Float Double]
      prim in [int float double]
      PrimVec in [V3i V3f V3d]
      PrimVecName in ["V3i" "V3f" "V3d"]
      PrimVec2 in [V2i V2f V2d]
      eset in [e3i e3f e3d]
      xset in [x3i x3f x3d]
      yset in [y3i y3f y3d]
      zset in [z3i z3f z3d]
      prim-fill in [V3i-fill V3f-fill V3d-fill]
      prim-unit in [V3i-unit V3f-unit V3d-unit]
      x0 in [0 0.0f 0.0]
      x1 in [1 1.0f 1.0]) :

  public lostanza deftype PrimVec <: Array<Prim> & Hashable & Geom :
    x: prim
    y: prim
    z: prim

  public lostanza defn PrimVec (x:ref<Prim>, y:ref<Prim>, z:ref<Prim>) -> ref<PrimVec> :
    return new PrimVec{x.value, y.value, z.value}

  public lostanza defn x (v:ref<PrimVec>) -> ref<Prim> :
    return new Prim{v.x}

  public lostanza defn y (v:ref<PrimVec>) -> ref<Prim> :
    return new Prim{v.y}

  public lostanza defn z (v:ref<PrimVec>) -> ref<Prim> :
    return new Prim{v.z}

  public defn PrimVec (x:Prim, y:Prim) -> PrimVec :
    PrimVec(x, y, x0)

  public defn prim-fill (a:Prim) : PrimVec(a, a, a)

  public defn prim-unit (i:Int) :
    if i == 0 :      PrimVec(x1, x0, x0)
    else if i == 1 : PrimVec(x0, x1, x0)
    else :           PrimVec(x0, x0, x1)

  public defn eset (i:Int, a:Prim) -> PrimVec : a * prim-unit(i)
  public defn xset (a:Prim) -> PrimVec : PrimVec(a, x0, x0)
  public defn yset (a:Prim) -> PrimVec : PrimVec(x0, a, x0)
  public defn zset (a:Prim) -> PrimVec : PrimVec(x0, x0, a)

  public defn set-elt (v:PrimVec, i:Int, a:Prim) -> PrimVec :
    PrimVec(a when i == 0 else v[0], a when i == 1 else v[1], a when i == 2 else v[2])

  lostanza defmethod get (v:ref<PrimVec>, i:ref<Int>) -> ref<Prim> : 
    ensure-index-in-bounds(i, new Int{3})
    return new Prim{addr!(v.x)[i.value]}

  defmethod length (a:PrimVec) -> Int : 3

  public defn area (a:PrimVec) -> Prim :
    x(a) * y(a)

  public defn volume (a:PrimVec) -> Prim :
    x(a) * y(a) * z(a)

  defmethod equal? (v1:PrimVec, v2:PrimVec) :
    x(v1) == x(v2) and y(v1) == y(v2) and z(v1) == z(v2) 

  defmethod hash (v:PrimVec) :
    (7 * ((7 * hash(x(v))) + hash(y(v)))) + hash(z(v))

  public defn xy (p:PrimVec) -> PrimVec2 :
    PrimVec2(x(p), y(p))

  public defn xyz (p:PrimVec) -> PrimVec : p

  public defn xyz (p:Prim) -> PrimVec : PrimVec(p, p, p)

  defmethod print (o:OutputStream, v:PrimVec) :
    print(o, "%_(%~, %~, %~)" % [PrimVecName, x(v), y(v), z(v)])

  public defn magnitude (a:PrimVec) -> Prim :
    sqrt(dot(a, a))

  public defn distance (v0:PrimVec, v1:PrimVec) -> Prim :
    magnitude(v1 - v0)

  public defn normalize (a:PrimVec) -> PrimVec :
    a / magnitude(a)

  public defn dot (a:PrimVec, b:PrimVec) -> Prim :
    x(a) * x(b) + y(a) * y(b) + z(a) * z(b)

  public defn min (a:PrimVec) -> Prim :
    min(x(a), min(y(a), z(a)))

  public defn max (a:PrimVec) -> Prim :
    max(x(a), max(y(a), z(a)))

  public defn min (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(min(x(a), x(b)), min(y(a), y(b)), min(z(a), z(b)))

  public defn max (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(max(x(a), x(b)), max(y(a), y(b)), max(z(a), z(b)))

  public defn times (a:Prim, b:PrimVec) -> PrimVec :
    PrimVec(a * x(b), a * y(b), a * z(b))

  public defn times (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(x(a) * x(b), y(a) * y(b), z(a) * z(b))

  public defn divide (a:PrimVec, b:Prim) -> PrimVec :
    PrimVec(x(a) / b, y(a) / b, z(a) / b)

  public defn divide (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(x(a) / x(b), y(a) / y(b), z(a) / z(b))

  public defn modulo (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(y(a) * z(b) - z(a) * y(b),
            z(a) * x(b) - x(a) * z(b),
            x(a) * y(b) - y(a) * x(b))

  public defn plus (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(x(a) + x(b), y(a) + y(b), z(a) + z(b))

  public defn minus (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(x(a) - x(b), y(a) - y(b), z(a) - z(b))

  public defn negate (a:PrimVec) -> PrimVec :
    PrimVec((- x(a)), (- y(a)), (- z(a)))

  public defn abs (a:PrimVec) -> PrimVec :
    PrimVec(abs(x(a)), abs(y(a)), abs(z(a)))

  public defn map (f:Prim -> Prim, v:PrimVec) -> PrimVec :
    PrimVec(f(x(v)), f(y(v)), f(z(v)))

  public defn round (p:PrimVec) -> PrimVec :
    PrimVec(round(x(p)), round(y(p)), round(z(p)))

  public defn sorted-indices (v:PrimVec) -> V3i :
    if x(v) < y(v) :
      if x(v) < z(v) :
        V3i(0, 1, 2) when y(v) < z(v) else V3i(0, 2, 1)
      else :
        V3i(2, 0, 1)
    else :
      if y(v) < z(v) :
        V3i(1, 0, 2) when x(v) < z(v) else V3i(1, 2, 0)
      else :
        V3i(2, 1, 0)

  public defn min-idx (v:PrimVec) -> Int :
    sorted-indices(v)[0]

  public defn mid-idx (v:PrimVec) -> Int :
    sorted-indices(v)[1]

  public defn max-idx (v:PrimVec) -> Int :
    sorted-indices(v)[2]

  public defn rnd (lo:PrimVec, hi:PrimVec) -> PrimVec :
    PrimVec(rnd(x(lo), x(hi)), rnd(y(lo), y(hi)), rnd(z(lo), z(hi)))


public defn indices (dims:V3i) -> Seq<V3i> :
  generate<V3i> :
    for k in 0 to z(dims) do :
      for j in 0 to y(dims) do :
        for i in 0 to x(dims) do :
          yield(V3i(i, j, k))

#for (Prim in [Float Double]
      PrimVec in [V3f V3d]) :
  public defn angle (a:PrimVec, b:PrimVec) -> Prim :
    acos(dot(a, b) / (magnitude(a) * magnitude(b)))

;;; V2x

#for (Prim in [Int Float Double]
      prim in [int float double]
      PrimVec in [V2i V2f V2d]
      PrimVecName in ["V2i" "V2f" "V2d"]
      PrimVec3 in [V3i V3f V3d]
      eset in [e2i e2f e2d]
      xset in [x2i x2f x2d]
      yset in [y2i y2f y2d]
      prim-fill in [V2i-fill V2f-fill V2d-fill]
      prim-unit in [V2i-unit V2f-unit V2d-unit]
      x0 in [0 0.0f 0.0]
      x1 in [1 1.0f 1.0]) :

  public lostanza deftype PrimVec <: Array<Prim> & Hashable & Geom :
    x: prim
    y: prim

  public lostanza defn PrimVec (x:ref<Prim>, y:ref<Prim>) -> ref<PrimVec> :
    return new PrimVec{x.value, y.value}

  public lostanza defn x (v:ref<PrimVec>) -> ref<Prim> :
    return new Prim{v.x}

  public lostanza defn y (v:ref<PrimVec>) -> ref<Prim> :
    return new Prim{v.y}

  public defn prim-fill (a:Prim) : PrimVec(a, a)

  public defn prim-unit (i:Int) :
    if i == 0 : PrimVec(x1, x0)
    else :      PrimVec(x0, x1)

  public defn eset (i:Int, a:Prim) -> PrimVec : a * prim-unit(i)
  public defn xset (a:Prim) -> PrimVec : PrimVec(a, x0)
  public defn yset (a:Prim) -> PrimVec : PrimVec(x0, a)

  public defn set-elt (v:PrimVec, i:Int, a:Prim) -> PrimVec :
    PrimVec(a when i == 0 else v[0], a when i == 1 else v[1])

  lostanza defmethod get (v:ref<PrimVec>, i:ref<Int>) -> ref<Prim> : 
    ensure-index-in-bounds(i, new Int{2})
    return new Prim{addr!(v.x)[i.value]}

  defmethod length (a:PrimVec) -> Int : 2

  public defn area (a:PrimVec) -> Prim :
    x(a) * y(a)

  public defn volume (a:PrimVec) -> Prim :
    x0

  defmethod equal? (v1:PrimVec, v2:PrimVec) :
    x(v1) == x(v2) and y(v1) == y(v2)

  defmethod hash (v:PrimVec) :
    ((7 * hash(x(v))) + hash(y(v)))

  public defn xy (p:PrimVec) -> PrimVec : p

  public defn xyz (p:PrimVec) -> PrimVec3 : PrimVec3(x(p), y(p), x0)

  public defn xy (p:Prim) -> PrimVec : PrimVec(p, p)

  defmethod print (o:OutputStream, v:PrimVec) :
    print(o, "%_(%~, %~)" % [PrimVecName, x(v), y(v)])

  public defn magnitude (a:PrimVec) -> Prim :
    sqrt(dot(a, a))

  public defn distance (v0:PrimVec, v1:PrimVec) -> Prim :
    magnitude(v1 - v0)

  public defn normalize (a:PrimVec) -> PrimVec :
    a / magnitude(a)

  public defn dot (a:PrimVec, b:PrimVec) -> Prim :
    x(a) * x(b) + y(a) * y(b)

  public defn min (a:PrimVec) -> Prim :
    min(x(a), y(a))

  public defn max (a:PrimVec) -> Prim :
    max(x(a), y(a))

  public defn min (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(min(x(a), x(b)), min(y(a), y(b)))

  public defn max (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(max(x(a), x(b)), max(y(a), y(b)))

  public defn times (a:Prim, b:PrimVec) -> PrimVec :
    PrimVec(a * x(b), a * y(b))

  public defn times (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(x(a) * x(b), y(a) * y(b))

  public defn divide (a:PrimVec, b:Prim) -> PrimVec :
    PrimVec(x(a) / b, y(a) / b)

  public defn divide (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(x(a) / x(b), y(a) / y(b))

  public defn plus (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(x(a) + x(b), y(a) + y(b))

  public defn minus (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(x(a) - x(b), y(a) - y(b))

  public defn negate (a:PrimVec) -> PrimVec :
    PrimVec((- x(a)), (- y(a)))

  public defn modulo (a:PrimVec, b:PrimVec) -> Prim :
    x(a) * y(b) - y(a) * x(b)

  public defn abs (a:PrimVec) -> PrimVec :
    PrimVec(abs(x(a)), abs(y(a)))

  public defn map (f:Prim -> Prim, v:PrimVec) -> PrimVec :
    PrimVec(f(x(v)), f(y(v)))

  public defn round (p:PrimVec) -> PrimVec :
    PrimVec(round(x(p)), round(y(p)))

  public defn sorted-indices (v:PrimVec) -> V2i :
    V2i(0, 1) when x(v) < y(v) else V2i(1, 0)

  public defn min-idx (v:PrimVec) -> Int :
    0 when x(v) < y(v) else 1

  public defn max-idx (v:PrimVec) -> Int :
    1 when x(v) < y(v) else 0

  public defn rnd (lo:PrimVec, hi:PrimVec) -> PrimVec :
    PrimVec(rnd(x(lo), x(hi)), rnd(y(lo), y(hi)))


#for (Prim in [Float Double]
      PrimVec in [V2f V2d]) :
  public defn angle (a:PrimVec, b:PrimVec) -> Prim :
    acos(dot(a, b) / (magnitude(a) * magnitude(b)))

public defn to-v3d (v:V3f) -> V3d :
  V3d(to-double(x(v)), to-double(y(v)), to-double(z(v)))

public defn to-v3i (v:V3f) -> V3i :
  V3i(to-int(x(v)), to-int(y(v)), to-int(z(v)))

public defn to-v3f (v:V3i) -> V3f :
  V3f(to-float(x(v)), to-float(y(v)), to-float(z(v)))

public defn to-v2i (v:V2f) -> V2i :
  V2i(to-int(x(v)), to-int(y(v)))

public defn to-v2f (v:V2i) -> V2f :
  V2f(to-float(x(v)), to-float(y(v)))

public defn V2f (x:Double, y:Double) -> V2f :
  V2f(to-float(x), to-float(y))

;;; V4f

;; public defstruct V4f <: Array<Float> :
;;   x: Float
;;   y: Float
;;   z: Float
;;   a: Float

val @doc-v4f = "4 DIM VECTORS -- color"

public lostanza deftype V4f <: Array<Float> & Geom & Hashable :
  x: float
  y: float
  z: float
  a: float

public lostanza defn V4f (x:ref<Float>, y:ref<Float>, z:ref<Float>, a:ref<Float>) -> ref<V4f> :
  return new V4f{x.value, y.value, z.value, a.value}

public lostanza defn x (v:ref<V4f>) -> ref<Float> :
  return new Float{v.x}

public lostanza defn y (v:ref<V4f>) -> ref<Float> :
  return new Float{v.y}

public lostanza defn z (v:ref<V4f>) -> ref<Float> :
  return new Float{v.z}

public lostanza defn a (v:ref<V4f>) -> ref<Float> :
  return new Float{v.a}

public defn V4f (x:Float, y:Float, z:Float) -> V4f :
  V4f(x, y, z, 0.0f)

public lostanza defmethod get (v:ref<V4f>, i:ref<Int>) -> ref<Float> :
  ensure-index-in-bounds(i, new Int{3})
  return new Float{addr!(v.x)[i.value]}

public defmethod length (a:V4f) -> Int : 4

defmethod equal? (v1:V4f, v2:V4f) :
  x(v1) == x(v2) and y(v1) == y(v2) and z(v1) == z(v2) and a(v1) == a(v2) 

defmethod hash (v:V4f) :
  (7 * ((7 * ((7 * hash(x(v))) + hash(y(v)))) + hash(z(v)))) + hash(a(v))

defmethod print (o:OutputStream, v:V4f) :
  print(o, "V4f(%~, %~, %~, %~)" % [x(v), y(v), z(v), z(v)])

public val RED   = V4f(1.0f, 0.0f, 0.0f, 1.0f)
public val GREEN = V4f(0.0f, 1.0f, 0.0f, 1.0f)
public val BLUE  = V4f(0.0f, 0.0f, 1.0f, 1.0f)
public val BLACK  = V4f(0.0f, 0.0f, 0.0f, 1.0f)
public val WHITE  = V4f(1.0f, 1.0f, 1.0f, 1.0f)

;;; BOX2 and BOX3

val @doc-box = "BOXES -- tracking bounds"

#for (Prim in [Int Float Double Int Float Double Int Float Double]
      BoxElt in [V3i V3f V3d V2i V2f V2d Int Float Double ]
      BoxName in ["Box3i" "Box3f" "Box3d" "Box2i" "Box2f" "Box2d" "Box1i" "Box1f" "Box1d"]
      BoxElt-fill in [V3i-fill V3f-fill V3d-fill V2i-fill V2f-fill V2d-fill to-int to-float to-double]
      Box in [Box3i Box3f Box3d Box2i Box2f Box2d Box1i Box1f Box1d]
      neg-inf in [neg-inf-i, neg-inf-f, neg-inf-d, neg-inf-i, neg-inf-f, neg-inf-d neg-inf-i, neg-inf-f, neg-inf-d]
      pos-inf in [pos-inf-i, pos-inf-f, pos-inf-d, pos-inf-i, pos-inf-f, pos-inf-d pos-inf-i, pos-inf-f, pos-inf-d]
      pos-inf-box in [pos-inf-box3i, pos-inf-box3f, pos-inf-box3d, pos-inf-box2i, pos-inf-box2f, pos-inf-box2d pos-inf-box1i, pos-inf-box1f, pos-inf-box1d]
      neg-inf-box in [neg-inf-box3i, neg-inf-box3f, neg-inf-box3d, neg-inf-box2i, neg-inf-box2f, neg-inf-box2d neg-inf-box1i, neg-inf-box1f, neg-inf-box1d]
      x2 in [2 2.0f 2.0, 2, 2.0f, 2.0, 2, 2.0f, 2.0]
      x0 in [0 0.0f 0.0, 0, 0.0f, 0.0, 0, 0.0f, 0.0]) :

  public defstruct Box <: Geom & Equalable :
    lo: BoxElt
    hi: BoxElt

  public defn Box (v:BoxElt) -> Box :
    Box(v, v)

  defmethod print (o:OutputStream, b:Box) :
    print-all(o, [BoxName "(", lo(b), ",", hi(b) ")"])

  public defn contains? (b:Box, p:BoxElt) -> True|False :
    not empty?(b & Box(p))

  public defn center (b:Box) -> BoxElt :
    (lo(b) + hi(b)) / x2

  public defn dims (b:Box) -> BoxElt :
    hi(b) - lo(b)

  public defn dims-to-box (dims:BoxElt) -> Box :
    val hdims = dims / x2
    Box((- hdims), hdims)

  public defn union (b:Box, v:BoxElt) -> Box :
    Box(min(lo(b), v), max(hi(b), v))

  public defn union (b0:Box, b1:Box) -> Box :
    Box(min(lo(b0), lo(b1)), max(hi(b0), hi(b1)))

  public defn bit-or (b0:Box, b1:Box) -> Box :
    union(b0, b1)

  public defn bit-and (b0:Box, b1:Box) -> Box :
    Box(max(lo(b0), lo(b1)), min(hi(b0), hi(b1)))

  public defn pos-inf-box () -> Box:
    Box(BoxElt-fill(neg-inf), BoxElt-fill(pos-inf))

  public defn neg-inf-box () -> Box:
    Box(BoxElt-fill(pos-inf), BoxElt-fill(neg-inf))

  public defn fatten (b:Box, amount:BoxElt) -> Box :
    Box(lo(b) - amount, hi(b) + amount)

  ;; public defn fatten (b:Box, dims:Prim) -> Box :
  ;;   fatten(b, BoxElt-fill(dims))

  public defn plus (b:Box, off:BoxElt) -> Box :
    Box(lo(b) + off, hi(b) + off)

  public defn minus (b:Box, off:BoxElt) -> Box :
    Box(lo(b) - off, hi(b) - off)

  defmethod equal? (b1:Box, b2:Box) :
    lo(b1) == lo(b2) and hi(b1) == hi(b2)

  public defn contains? (b0:Box, b1:Box) -> True|False :
    contains?(b0, lo(b1)) and contains?(b0, hi(b1))

  public defn clamp (b:Box, v:BoxElt) -> BoxElt :
    max(lo(b), min(hi(b), v))

public defn indices (bounds:Box3i) -> Seq<V3i> :
  generate<V3i> :
    for k in z(lo(bounds)) through z(hi(bounds)) do :
      for j in y(lo(bounds)) through y(hi(bounds)) do :
        for i in x(lo(bounds)) through x(hi(bounds)) do :
          yield(V3i(i, j, k))

public defn indices (bounds:Box2i) -> Seq<V2i> :
  generate<V2i> :
    for j in y(lo(bounds)) through y(hi(bounds)) do :
      for i in x(lo(bounds)) through x(hi(bounds)) do :
        yield(V2i(i, j))

#for (BoxElt in [Int Float Double]
      Box in [Box1i Box1f Box1d]
      Box2 in [Box2i Box2f Box2d]
      Box3 in [Box3i Box3f Box3d]
      x0 in [0 0.0f 0.0]) :

  public defn xy (b:Box) : Box2(xy(lo(b)), xy(hi(b)))

  public defn xyz (b:Box) : Box3(xyz(lo(b)), xyz(hi(b)))

  public defn empty? (b:Box) -> True|False :
    dims(b) < x0

  public defn corners (b:Box) -> Tuple<BoxElt> :
    [lo(b), hi(b)]

  public defn intersects? (b0:Box, b1:Box) -> True|False :
    not (hi(b0) < lo(b1) or lo(b0) > hi(b1))

#for (BoxElt in [V2i V2f V2d]
      Box in [Box2i Box2f Box2d]
      Box3 in [Box3i Box3f Box3d]
      x0 in [0 0.0f 0.0]) :

  public defn xy (b:Box) -> Box : b

  public defn xyz (b:Box) -> Box3 :
    Box3(xyz(lo(b)), xyz(hi(b)))

  public defn empty? (b:Box) -> True|False :
    val d = dims(b)
    x(d) < x0 or y(d) < x0

  public defn corners (b:Box) -> Tuple<BoxElt> :
    val [l, h] = [lo(b), hi(b)]
    [BoxElt(x(l), y(l)),
     BoxElt(x(l), y(h)), 
     BoxElt(x(h), y(h)),
     BoxElt(x(h), y(l))] 

  public defn intersects? (b0:Box, b1:Box) -> True|False :
    not ((x(hi(b0)) < x(lo(b1)) or x(lo(b0)) > x(hi(b1))) or
         (y(hi(b0)) < y(lo(b1)) or y(lo(b0)) > y(hi(b1))))

#for (BoxElt in [V3i V3f V3d]
      Box in [Box3i Box3f Box3d]
      Box2 in [Box2i Box2f Box2d]
      x0 in [0 0.0f 0.0]) :

  public defn xy (b:Box) -> Box2 :
    Box2(xy(lo(b)), xy(hi(b)))

  public defn xyz (b:Box) -> Box : b

  public defn empty? (b:Box) -> True|False :
    val d = dims(b)
    x(d) < x0 or y(d) < x0 or z(d) < x0

  public defn corners (b:Box) -> Tuple<BoxElt> :
    val [l, h] = [lo(b), hi(b)]
    [BoxElt(x(l), y(l), z(l)),
     BoxElt(x(l), y(l), z(h)), 
     BoxElt(x(l), y(h), z(h)),
     BoxElt(x(h), y(h), z(h)),
     BoxElt(x(h), y(l), z(h)),
     BoxElt(x(h), y(l), z(l)), 
     BoxElt(x(h), y(h), z(l)), 
     BoxElt(x(l), y(h), z(l))
     ]

  public defn intersects? (b0:Box, b1:Box) -> True|False :
    not ((x(hi(b0)) < x(lo(b1)) or x(lo(b0)) > x(hi(b1))) or
         (y(hi(b0)) < y(lo(b1)) or y(lo(b0)) > y(hi(b1))) or
         (z(hi(b0)) < z(lo(b1)) or z(lo(b0)) > z(hi(b1))))

public defn times (mat:Mat44f, b:Box3f) -> Box3f :
  reduce(union, map(Box3f{ mat * _ }, corners(b)))

public defn times (mat:Mat44f, b:Box2f) -> Box2f :
  reduce(union, map(Box2f{ xy(mat * xyz(_)) }, corners(b)))

public val pos-inf-f =  1.0e6f
public val neg-inf-f = -1.0e6f
public val pos-inf-d =  1.0e6
public val neg-inf-d = -1.0e6
public val pos-inf-i =  (1 << 30)
public val neg-inf-i = (-(1 << 30))

;;; MAT

val @doc-mat44f = "MAT44f -- 4D affine transformation matrix"

public lostanza deftype Mat44f <: Array<Float> & Equalable :
  m00: float
  m01: float
  m02: float
  m03: float
  m10: float
  m11: float
  m12: float
  m13: float
  m20: float
  m21: float
  m22: float
  m23: float
  m30: float
  m31: float
  m32: float
  m33: float

public lostanza defn Mat44f (m00:ref<Float>,m01:ref<Float>,m02:ref<Float>,m03:ref<Float>,
                             m10:ref<Float>,m11:ref<Float>,m12:ref<Float>,m13:ref<Float>,
                             m20:ref<Float>,m21:ref<Float>,m22:ref<Float>,m23:ref<Float>,
                             m30:ref<Float>,m31:ref<Float>,m32:ref<Float>,m33:ref<Float>) -> ref<Mat44f> :
  return new Mat44f{m00.value,m01.value,m02.value,m03.value,m10.value,m11.value,m12.value,m13.value,
                    m20.value,m21.value,m22.value,m23.value,m30.value,m31.value,m32.value,m33.value}

public defn Mat44f (m:Mat44f) -> Mat44f :
  Mat44f(m[0, 0], m[0, 1], m[0, 2], m[0, 3],
         m[1, 0], m[1, 1], m[1, 2], m[1, 3], 
         m[2, 0], m[2, 1], m[2, 2], m[2, 3], 
         m[3, 0], m[3, 1], m[3, 2], m[3, 3])

lostanza defn mat44f-get (m:ref<Mat44f>, i:ref<Int>) -> ref<Float> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, new Int{16})
  return new Float{addr!(m.m00)[i.value]}

lostanza defn mat44f-set (m:ref<Mat44f>, i:ref<Int>, x:ref<Float>) -> ref<False> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, new Int{16})
  addr!(m.m00)[i.value] = x.value
  return false

defmethod equal? (m1:Mat44f, m2:Mat44f) :
  label<True|False> return:
    for i in 0 to 4 do :
      for j in 0 to 4 do :
        if m1[i, j] != m2[i, j] : return(false)
    true

defmethod get (a:Mat44f, i:Int) -> Float : mat44f-get(a, i)
defmethod set (a:Mat44f, i:Int, c:Float) -> False : mat44f-set(a, i, c)
defmethod length (a:Mat44f) -> Int : 16

public defn get (m:Mat44f, x:Int, y:Int) -> Float :
  m[x * 4 + y]

public defn set (m:Mat44f, x:Int, y:Int, v:Float) -> False :
  m[x * 4 + y] = v

defmethod print (o:OutputStream, m:Mat44f) :
  print(o, "MAT(")
  for (i in 0 to 16) do :
     if i > 0 : print(o, ",")
     print(o, m[i])
  print-all(o, ")")

public defn gj-inverse (m:Mat44f) -> Mat44f :
  label<Mat44f> return :
    val s = id-mat44f()
    val t = Mat44f(m)
    for i in 0 to 3 do :
      var pivot = i
      var pivot-size:Float = t[i, i]
      if pivot-size < 0.0f :
        pivot-size = (- pivot-size)
      for j in (i + 1) to 4 do :
        var tmp:Float = t[j, i]
        if tmp < 0.0f :
          tmp = (- tmp)
        if tmp > pivot-size :
          pivot = j
          pivot-size = tmp
        if pivot-size == 0.0f :
          println(["SINGULAR"])
          ;; if singExc : throw SingMatrixExc ("Cannot invert singular matrix.")
          return(id-mat44f())
        if pivot != i :
          for j in 0 to 4 do :
            var tmp = t[i, j]
            t[i, j] = t[pivot, j]
            t[pivot, j] = tmp
            tmp = s[i, j]
            s[i, j] = s[pivot, j]
            s[pivot, j] = tmp

        for j in (i + 1) to 4 do :
          val f = t[j, i] / t[i, i]
          for k in 0 to 4 do :
            t[j, k] = t[j, k] - f * t[i, k]
            s[j, k] = s[j, k] - f * s[i, k]

    ;; Backward substitution

    for i in 3 through 0 by -1 do :
      val f = t[i, i]
      if f == 0.0f :
        println-all(["SINGULAR"])
        ;; if singExc : throw(SingMatrixExc ("Cannot invert singular matrix."))
        return(id-mat44f())
      for j in 0 to 4 do :
        t[i, j] = t[i, j] / f
        s[i, j] = s[i, j] / f
      for j in 0 to i do :
        val g = t[j, i]
        for k in 0 to 4 do :
          t[j, k] = t[j, k] - g * t[i, k]
          s[j, k] = s[j, k] - g * s[i, k]
    s

public defn inverse (m:Mat44f) -> Mat44f :
  label<Mat44f> return :
    if m[0, 3] != 0.0f or m[1, 3] != 0.0f or m[2, 3] != 0.0f or m[3, 3] != 1.0f :
      return(gj-inverse(m))
    val s = Mat44f(m[1, 1] * m[2, 2] - m[2, 1] * m[1, 2],
                  m[2, 1] * m[0, 2] - m[0, 1] * m[2, 2],
                  m[0, 1] * m[1, 2] - m[1, 1] * m[0, 2],
                  0.0f,

                  m[2, 0] * m[1, 2] - m[1, 0] * m[2, 2],
                  m[0, 0] * m[2, 2] - m[2, 0] * m[0, 2],
                  m[1, 0] * m[0, 2] - m[0, 0] * m[1, 2],
                  0.0f,

                  m[1, 0] * m[2, 1] - m[2, 0] * m[1, 1],
                  m[2, 0] * m[0, 1] - m[0, 0] * m[2, 1],
                  m[0, 0] * m[1, 1] - m[1, 0] * m[0, 1],
                  0.0f,

                  0.0f,
                  0.0f,
                  0.0f,
                  1.0f)
     val r = m[0, 0] * s[0, 0] + m[0, 1] * s[1, 0] + m[0, 2] * s[2, 0]
     if (abs(r) >= 1.0f) :
       for i in 0 to 3 do :
         for j in 0 to 3 do :
           s[i, j] = s[i, j] / r
     else :
       val mr = abs(r) / FLOAT-MIN ;; smallest
       for i in 0 to 3 do :
         for j in 0 to 3 do :
           if mr > abs(s[i, j]) :
             s[i, j] = s[i, j] / r
           else :
             println-all(["SINGULAR " m])
             ;; if singExc : throw(SingMatrixExc ("Cannot invert singular matrix."))
             return(id-mat44f())
             
    s[3, 0] = (- m[3, 0]) * s[0, 0] - m[3, 1] * s[1, 0] - m[3, 2] * s[2, 0]
    s[3, 1] = (- m[3, 0]) * s[0, 1] - m[3, 1] * s[1, 1] - m[3, 2] * s[2, 1]
    s[3, 2] = (- m[3, 0]) * s[0, 2] - m[3, 1] * s[1, 2] - m[3, 2] * s[2, 2]

    s

public defn reflect-xy-mat44f () -> Mat44f :
  Mat44f( 0.0f,  1.0f,  0.0f,  0.0f,
          1.0f,  0.0f,  0.0f,  0.0f,
          0.0f,  0.0f,  1.0f,  0.0f,
          0.0f,  0.0f,  0.0f,  1.0f)
 
public defn reflect-xz-mat44f () -> Mat44f :
  Mat44f( 0.0f,  0.0f,  1.0f,  0.0f,
          0.0f,  1.0f,  0.0f,  0.0f,
          1.0f,  0.0f,  0.0f,  0.0f,
          0.0f,  0.0f,  0.0f,  1.0f)
 
public defn reflect-yz-mat44f () -> Mat44f :
  Mat44f( 1.0f,  0.0f,  0.0f,  0.0f,
          0.0f,  0.0f,  1.0f,  0.0f,
          0.0f,  1.0f,  0.0f,  0.0f,
          0.0f,  0.0f,  0.0f,  1.0f)
 
public defn shear-x-y-mat44f (ymin:Float, ymax:Float, dx0:Float, dx1:Float) -> Mat44f :
  ;; TODO
  id-mat44f()
 
public defn id-mat44f () -> Mat44f : mag-mat44f(1.0f)

public defn mag-mat44f (s:Float) -> Mat44f :
  Mat44f(   s, 0.0f, 0.0f, 0.0f,
         0.0f,    s, 0.0f, 0.0f,
         0.0f, 0.0f,    s, 0.0f,
         0.0f, 0.0f, 0.0f, 1.0f)
 
public defn mag-mat44f (s:V3f) -> Mat44f :
  Mat44f(x(s), 0.0f, 0.0f, 0.0f,
         0.0f, y(s), 0.0f, 0.0f,
         0.0f, 0.0f, z(s), 0.0f,
         0.0f, 0.0f, 0.0f, 1.0f)

public defn mov-mat44f (t:V3f) -> Mat44f :
  Mat44f( 1.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 1.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 1.0f, 0.0f,
          t[0], t[1], t[2], 1.0f)

public defn rot-mat44f (r:V3f) -> Mat44f :
  val cos_rz = cos(r[2])
  val cos_ry = cos(r[1])
  val cos_rx = cos(r[0])

  val sin_rz = sin(r[2])
  val sin_ry = sin(r[1])
  val sin_rx = sin(r[0])

  val m00 = cos_rz * cos_ry
  val m01 = sin_rz * cos_ry
  val m02 = (- sin_ry)
  val m10 = (- sin_rz) * cos_rx + cos_rz * sin_ry * sin_rx
  val m11 = cos_rz * cos_rx + sin_rz * sin_ry * sin_rx
  val m12 = cos_ry * sin_rx
  val m20 = (- sin_rz) * (- sin_rx) + cos_rz * sin_ry * cos_rx
  val m21 = cos_rz * (- sin_rx) + sin_rz * sin_ry * cos_rx
  val m22 = cos_ry * cos_rx

  Mat44f( m00,  m01,  m02, 0.0f,
          m10,  m11,  m12, 0.0f,
          m20,  m21,  m22, 0.0f,
         0.0f, 0.0f, 0.0f, 1.0f)

public defn rot-mat44f (axis:V3f, angle:Float) -> Mat44f :
  if abs(sin(angle)) < 1.0e-06f :
    id-mat44f()
  else :
    quat-to-mat44f(quat-from-axis(normalize(axis), angle))

public defn rot-mat44f (b:V3f, a:V3f) -> Mat44f :
  val ang = angle(a, b)
  val cross = a % b
  if magnitude(cross) <= 1.0e-06f :
    mag-mat44f(1.0f when abs(ang) <= 1.0e-06f else -1.0f)
    ;; val e = V3f-unit(min-idx(abs(a)))
    ;; e - dot(e, a) * a
  else :
    rot-mat44f(cross, ang)

public defn rot-mat44f (start:Tuple<V3f>, end:Tuple<V3f>) -> Mat44f :
  ;; val world = [x3f(1.0f), y3f(1.0f), z3f(1.0f)]
  Mat44f(  dot(end[0], start[0]), dot(end[0], start[1]), dot(end[0], start[2]), 0.0f, 
           dot(end[1], start[0]), dot(end[1], start[1]), dot(end[1], start[2]), 0.0f, 
           dot(end[2], start[0]), dot(end[2], start[1]), dot(end[2], start[2]), 0.0f, 
                            0.0f,                  0.0f,                  0.0f, 1.0f)

public defn rot-mat44f (src:V2f, dst:V2f) -> Mat44f :
  val a = atan2(y(dst), x(dst)) - atan2(y(src), x(src))
  val [c, s] = [cos(a), sin(a)]
  Mat44f(    c    s 0.0f 0.0f
         (- s)    c 0.0f 0.0f
          0.0f 0.0f 1.0f 0.0f
          0.0f 0.0f 0.0f 1.0f)

public defn rot-mat44f (m:Mat44f) -> Mat44f :
  Mat44f(m[ 0], m[ 1], m[ 2], 0.0f,
         m[ 4], m[ 5], m[ 6], 0.0f,
         m[ 8], m[ 9], m[10], 0.0f,
          0.0f,  0.0f,  0.0f, 1.0f)
          
public defn times (m:Mat44f, v:V3f) -> V3f :
  val px = x(v) * m[0,0] + y(v) * m[1,0] + z(v) * m[2,0] + m[3,0]
  val py = x(v) * m[0,1] + y(v) * m[1,1] + z(v) * m[2,1] + m[3,1]
  val pz = x(v) * m[0,2] + y(v) * m[1,2] + z(v) * m[2,2] + m[3,2]
  val pw = x(v) * m[0,3] + y(v) * m[1,3] + z(v) * m[2,3] + m[3,3]
  V3f(px / pw, py / pw, pz / pw)

public defn times (m:Mat44f, v:V2f) -> V2f :
  val px = x(v) * m[0,0] + y(v) * m[1,0] + m[3,0]
  val py = x(v) * m[0,1] + y(v) * m[1,1] + m[3,1]
  val pw = x(v) * m[0,3] + y(v) * m[1,3] + m[3,3]
  V2f(px / pw, py / pw)

public defn times (a:Mat44f, b:Mat44f) -> Mat44f :
  val res = id-mat44f()
  for i in 0 to 4 do :
    for j in 0 to 4 do :
      var sum: Float = 0.0f
      for k in 0 to 4 do :
        sum = sum + a[i,k] * b[k,j]
      res[i, j] = sum
  res

;;; QUAT

val @doc-quat = "QUAT -- quaternions for interpolatable rotations"

public defstruct Quat <: Equalable :
  w: Float
  v: V3f

public defn quat-from-axis (axis:V3f, rads:Float) -> Quat :
  val angle = rads / 2.0f
  val sin-angle = sin(angle)
  val n = normalize(axis)
  Quat(cos(angle), sin-angle * n)

public defn sin-cos (a:Float) : [ sin(a) cos(a) ]

public defn quat-from-euler (radz:V3f) -> Quat :
  val [sr cr] = sin-cos(0.5f * x(radz))
  val [sp cp] = sin-cos(0.5f * y(radz))
  val [sy cy] = sin-cos(0.5f * z(radz))
  Quat(    cy * cr * cp + sy * sr * sp,
       V3f(cy * sr * cp - sy * cr * sp,
           cy * cr * sp + sy * sr * cp,
           sy * cr * cp - cy * sr * sp))

val zero-quat = quat-from-axis(V3f(1.0f, 0.0f, 0.0f), 0.0f)

public defn zero? (q:Quat) : q == zero-quat

public defn Quat () : zero-quat

defmethod print (o:OutputStream, q:Quat) :
  print-all(o, ["Quat(" v(q) "," w(q) ")"])

defmethod equal? (q1:Quat, q2:Quat) :
  v(q1) == v(q2) and w(q1) == w(q2) 

public defn times (s:Float, q:Quat) -> Quat :
  Quat(s * w(q), s * v(q))

public defn divide (q:Quat, d:Float) -> Quat :
  Quat(w(q) / d, v(q) / d)

public defn x (q:Quat) -> Float : x(v(q))
public defn y (q:Quat) -> Float : y(v(q))
public defn z (q:Quat) -> Float : z(v(q))

public defn times (q1:Quat, q2:Quat) -> Quat :
  Quat(w(q1) * w(q2) - dot(v(q1), v(q2)), w(q1) * v(q2) + w(q2) * v(q1) + v(q1) % v(q2))

public defn dot (q1:Quat, q2:Quat) -> Float :
  dot(v(q1), v(q2)) + w(q1) * w(q2)

public defn conjugate (q:Quat) -> Quat :
  Quat(w(q), (- v(q)))

public defn negate (q:Quat) -> Quat :
  conjugate(q) / dot(q, q)

public defn magnitude (q:Quat) -> Float :
  sqrt(dot(q, q))

public defn normalize (q:Quat) -> Quat :
  q / magnitude(q)

val DELTA = 0.95f

public defn slerp (src:Quat, dst0:Quat, t:Float) -> Quat :
  val cosom0 = dot(src, dst0)
  val [cosom, dst] =
    if cosom0 < 0.0f :
      [(- cosom0), -1.0f * dst0]
    else :
      [cosom0, dst0]
  val [s0, s1] =
    if (1.0f - cosom) > DELTA :
      val omega = acos(cosom)
      val sinom = sin(omega)
      [sin((1.0f - t) * omega) / sinom, sin(t * omega) / sinom]
    else :
      [1.0f - t, t]
  Quat(s0 * w(src) + s1 * w(dst), s0 * v(src) + s1 * v(dst))

public defn quat-to-mat44f (q:Quat) -> Mat44f :
  val [ wx,  wy,  wz] = [w(q) * x(q), w(q) * y(q), w(q) * z(q)]
  val [ xx,  xy,  xz] = [x(q) * x(q), x(q) * y(q), x(q) * z(q)]
  val [ yy,  yz,  zz] = [y(q) * y(q), y(q) * z(q), z(q) * z(q)]
  val [m00, m01, m02] = [1.0f - 2.0f * (yy + zz),        2.0f * (xy - wz),        2.0f * (xz + wy)]
  val [m10, m11, m12] = [       2.0f * (xy + wz), 1.0f - 2.0f * (xx + zz),        2.0f * (yz - wx)]
  val [m20, m21, m22] = [       2.0f * (xz - wy),        2.0f * (yz + wx), 1.0f - 2.0f * (xx + yy)]
  Mat44f( m00,  m01,  m02, 0.0f,
          m10,  m11,  m12, 0.0f,
          m20,  m21,  m22, 0.0f,
         0.0f, 0.0f, 0.0f, 1.0f)

;;; ARCBALL

val epsilon = 0.000001f

public defstruct ArcBall :
  st-vec: V3f with: (setter => st-vec-set)
  en-vec: V3f with: (setter => en-vec-set)
  adjust-width: Float with: (setter => adjust-width-set)
  adjust-height: Float with: (setter => adjust-height-set)
  quat : Quat with: (setter => set-quat)
  base-quat : Quat with: (setter => set-base-quat)
  rot : Mat44f with: (setter => set-rot)

public defn clone (ball:ArcBall) :
  ArcBall(adjust-width(ball), adjust-height(ball))
  
public defn set-bounds (a:ArcBall, new-width:Float, new-height:Float) :
  ;; adjust-width-set(a, 1.0f / ((new-width - 1.0f) * 0.5f))
  ;; adjust-height-set(a, 1.0f / ((new-width - 1.0f) * 0.5f))
  adjust-width-set(a, new-width)
  adjust-height-set(a, new-height)

defn clip (x:Float, mn:Float, mx:Float) -> Float :
  min(mx, max(mn, x))

public defn map-to-sphere (a:ArcBall, new-pt:V2f) -> V3f :
  ;; val pt = V2f(x(new-pt) * adjust-width(a) - 1.0f, 1.0f - (y(new-pt) * adjust-height(a)))
  val pt = V2f(clip((-(2.0f * x(new-pt) / adjust-width(a)  - 1.0f)), -1.0f, 1.0f),
               clip(  (2.0f * y(new-pt) / adjust-height(a) - 1.0f),  -1.0f, 1.0f))
  ;; println-all(["NEW-PT " new-pt " AW " adjust-width(a) " AH " adjust-height(a) " PT = " pt])
  val len2 = dot(pt, pt)
  val res = 
    if len2 > 1.0f :
      ;; (1.0f / sqrt(len2)) * pt
      ;; println("> 1.0f")
      val len  = sqrt(len2)
      val res  = V3f(x(pt), y(pt), 1.0f / len)
      val rlen = sqrt(len2 + z(res) * z(res))
      normalize(res / rlen)
    else :
      V3f(x(pt), y(pt), sqrt(1.0f - len2))
  ;; println-all(["RES = " res])
  res

public defn ArcBall (new-width:Float, new-height:Float) -> ArcBall :
  val res = ArcBall(V3f(0.0f, 0.0f, 0.0f), V3f(0.0f, 0.0f, 0.0f), 0.0f, 0.0f, Quat(), Quat(), id-mat44f())
  set-bounds(res, new-width, new-height)
  res

public defn click (a:ArcBall, new-pt:V2f) :
  ;; println-all(["CLICK " new-pt])
  st-vec-set(a, map-to-sphere(a, new-pt))
  set-quat(a, base-quat(a))

public defn reset! (a:ArcBall) :
  set-rot(a, id-mat44f())
  set-quat(a, Quat())
  set-base-quat(a, Quat())

public defn drag (a:ArcBall, new-pt:V2f) :
  ;; println-all(["DRAG  " new-pt])
  en-vec-set(a, map-to-sphere(a, new-pt))
  val perp = st-vec(a) % en-vec(a)
  if magnitude(perp) > epsilon :
    val q = normalize(Quat(dot(st-vec(a), en-vec(a)), perp))
    ;; set-quat(a, (- q) * base-quat(a))
    ;; set-quat(a, conjugate(q) * base-quat(a))
    ;; set-quat(a, base-quat(a) * conjugate(q))
    set-quat(a, base-quat(a) * q)
    set-rot(a, quat-to-mat44f(quat(a)))
    q
    
public defn complete-drag (a:ArcBall) :
 set-base-quat(a, quat(a))

var MOV-AMOUNT:Float = 2000.0f
public defn mov-amount () : MOV-AMOUNT
public defn set-mov-amount (a:Float) : MOV-AMOUNT = a

public val MAG-SCALE  = 0.008f
public val MOV-SCALE  = 0.0001f

public defstruct Transformation :
  ball : ArcBall with: (setter => set-ball)
  mag : Float with: (setter => set-mag)
  mov : V2f with: (setter => set-mov)
  last-x : Float with: (setter => set-last-x)

public defn clone (xform:Transformation) :
  Transformation(clone(ball(xform)), mag(xform), V2f(0.0f, 0.0f), 0.0f)

public defn mov! (xform:Transformation, amount:V2f) :
  set-mov(xform, mov(xform) + MOV-SCALE * amount)

public defn reset! (t:Transformation) :
  reset!(ball(t))
  set-mov(t, V2f(0.0f, 0.0f))
  set-mag(t, 1.0f)
  set-last-x(t, 0.0f)

;;;; POSEABLES

val @doc-poseable = "POSEABLES -- geom with attributes and bounds and moveable"

public deftype Poseable <: Geom
public defmulti clone<?T> (s:?T&Poseable, name:False|Symbol, color:V4f, poses:Tuple<KeyValue<Symbol,Mat44f>>, tags:Tuple<Symbol>) -> T
public defmulti name (p:Poseable) -> False|Symbol
public defmulti color (p:Poseable) -> V4f
public defmulti tags (p:Poseable) -> Tuple<Symbol>
public defmulti poses (p:Poseable) -> Tuple<KeyValue<Symbol,Mat44f>>
public defmulti bounds (p:Poseable) -> Box3f
public defmulti xyz<?T> (mat:Mat44f, p:?T&Poseable) -> T
public defmulti any-shapes (p:Poseable) -> Seqable<AnyShape>
public defmulti get (s:Poseable, iname:Symbol) -> False|Poseable
public defmulti update (s:Poseable, iname:Symbol, value:Poseable) -> Poseable

public defn rgb<?T> (c:V4f, p:?T&Poseable) -> T : clone(p, name(p), c, poses(p), tags(p))
public defn set-name<?T> (name:Symbol, p:?T&Poseable) -> T : clone(p, name, color(p), poses(p), tags(p))

public defn mov<?T> (dp:V3f, s:?T&Poseable) -> T : xyz(mov-mat44f(dp), s)

public defn mov-x<?T> (dx:Float, p:?T&Poseable) -> T : mov(V3f(dx, 0.0f, 0.0f), p)
public defn mov-y<?T> (dy:Float, p:?T&Poseable) -> T : mov(V3f(0.0f, dy, 0.0f), p)
public defn mov-z<?T> (dz:Float, p:?T&Poseable) -> T : mov(V3f(0.0f, 0.0f, dz), p)
public defn mov (d:V3f)     : mov{d, _}
public defn mov-x (d:Float) : mov-x{d, _}
public defn mov-y (d:Float) : mov-y{d, _}
public defn mov-z (d:Float) : mov-z{d, _}

public defn center<?T> (p:?T&Poseable) -> T :
  mov((- center(bounds(p))), p)

public defn center-x<?T> (p:?T&Poseable) -> T :
  mov-x((- x(center(bounds(p)))), p)

public defn center-y<?T> (p:?T&Poseable) -> T :
  mov-x((- y(center(bounds(p)))), p)

public defn center-z<?T> (p:?T&Poseable) -> T :
  mov-x((- z(center(bounds(p)))), p)

public defn corners<?T> (box:Box2f, s:?T&Poseable) -> Seqable<T> :
  seq(mov{xyz(_), s}, corners(box))

public defn any-shapes (s:Seqable<AnyShape>) : s

public defn rgb (c:V4f) : rgb{c, _}

public defmulti bit-or<?T> (a:?T&AnyShape, b:T&AnyShape) -> T

public defn union<?T> (args:Seqable<?T&AnyShape>) -> T :
  ;; reduce(bit-or, empty(), cat-all(seq(shapes, args)))
  ;; reduce(bit-or, empty(), args)
  reduce(bit-or, args)

public defn union-or<?T> (args:Seqable<?T&AnyShape>, default:T&AnyShape) -> T :
  reduce(bit-or, default, args)

;;; ASSEMBLIES

val @doc-assembly = "ASSEMBLY -- grouping poseables"

public deftype Assembly<T> <: Poseable
public defmulti children (a:Assembly) -> Tuple<Poseable>
public defmulti mat (l:Assembly) -> Mat44f

public defn Assembly<?T> (mat:Mat44f, name:False|Symbol, color:V4f, poseables:Seqable<?T&Poseable>) -> Assembly<T> :
  val children = to-tuple $ poseables
  ;; if length(children) == 0 : fatal("EMPTY CHILDREN")
  new Assembly<T> :
    defmethod children (this) : children
    defmethod name (this) : name
    defmethod tags (this) : to-tuple $ unique $ cat-all $ seq(tags, children)
    defmethod bounds (this) : mat * reduce(bit-or, seq(bounds, children))
    defmethod mat (this) : mat
    defmethod color (this) : color
    defmethod any-shapes (this) : seq(rgb{color, _}, seq(xyz{mat, _}, cat-all $ seq(any-shapes, children)))
    defmethod poses (this) : to-tuple $ cat-all $ seq(poses, children)

public defn ungroup (a:Assembly) -> Seqable<Poseable> :
  seq(rgb{color(a), _}, seq(xyz{mat(a), _}, children(a)))

defmethod clone (p:Assembly, name:False|Symbol, color:V4f, poses:Tuple<KeyValue<Symbol,Mat44f>>, tags:Tuple<Symbol>) -> Assembly :
  Assembly(mat(p), name, color, children(p))

public defn Assembly<?T> (mat:Mat44f, poseables:Seqable<?T&Poseable>) -> Assembly<T> :
  Assembly(mat, false, WHITE, poseables)
  
public defn Assembly<?T> (poseables:Seqable<?T&Poseable>) -> Assembly<T> :
  Assembly(id-mat44f(), poseables)
  
public defmethod get (s:AnyShape, iname:Symbol) -> False|AnyShape :
  s when iname == name(s)

public defmethod get (a:Assembly, iname:Symbol) -> False|Poseable :
  if iname == name(a) :
    a
  else :
    label<False|Poseable> return :
      for c in children(a) do :
        val e = c[iname]
        return(e) when e is-not False

public defmethod update (s:AnyShape, iname:Symbol, value:AnyShape) -> AnyShape :
  value when iname == name(s) else s

public defmethod update (a:Assembly, iname:Symbol, value:Poseable) -> Poseable :
  if iname == name(a) :
    value
  else :
    label<Assembly> return :
      val ncs = for c in children(a) seq :
        update(c, iname, value)
      Assembly(mat(a), name(a), color(a), ncs)

public defn group (poseables:Seqable<Poseable>) : Assembly(poseables)

defmethod print (s:OutputStream, a:Assembly) :
  print(s, "Assembly(%_ %,)" % [name(a), children(a)])

public defmethod xyz (xf:Mat44f, a:Assembly) :
  Assembly(mat(a) * xf, name(a), color(a), children(a))

defn do-print-svg (s:OutputStream, assembly:Assembly) :
  for elt in children(assembly) do :
    match(elt) :
      (c:PolyLine2f|Polygon|Assembly) : do-print-svg(s, xyz(mat(assembly), c))
      (c) : false

;;; ANYSHAPE

public defstruct AnyShapeState :
  name : False|Symbol
  color : V4f
  tags : Tuple<Symbol>
  poses : Tuple<KeyValue<Symbol,Mat44f>>

val @doc-anyshape = "ANYSHAPE -- leaf poseables allowing more transformations"

public deftype AnyShape <: Poseable
public defmulti state (a:AnyShape) -> AnyShapeState
public defmulti clone<?T> (shape:?T&AnyShape, state:AnyShapeState) -> T
public defmethod name (p:AnyShape) : name(state(p))
public defmethod color (p:AnyShape) : color(state(p))
public defmethod tags (p:AnyShape) : tags(state(p))
public defmethod poses (p:AnyShape) : poses(state(p))

defmethod any-shapes (p:AnyShape) : [p] ;; DEFAULT

public defn bit-or (a:AnyShapeState, b:AnyShapeState) -> AnyShapeState :
  AnyShapeState(name(a) when name(a) is Symbol else name(b), color(a),
                to-tuple $ cat(tags(a), tags(b)), to-tuple $ cat(poses(a), poses(b)))

defmethod clone (s:AnyShape, name:False|Symbol, color:V4f, poses:Tuple<KeyValue<Symbol,Mat44f>>, tags:Tuple<Symbol>) :
  clone(s, AnyShapeState(name, color, tags, poses))

public defn add-poses<?T> (s:?T&AnyShape, poses:Tuple<KeyValue<Symbol,Mat44f>>) -> T :
  clone(s, AnyShapeState(name(s), color(s), tags(s), poses))
public defn add-tags<?T> (s:?T&AnyShape, tags:Tuple<Symbol>) -> T :
  clone(s, AnyShapeState(name(s), color(s), tags, poses(s)))

public defn add-min-x-pose<?T> (s:?T&AnyShape, dir:Float) -> T :
  add-poses(s, [`min-x => pose-mat44f(x3f(x(lo(bounds(s)))), y3f(dir *  90.0f))])
public defn add-max-x-pose<?T> (s:?T&AnyShape, dir:Float) -> T :
  add-poses(s, [`max-x => pose-mat44f(x3f(x(hi(bounds(s)))), y3f(dir * -90.0f))])
public defn add-min-y-pose<?T> (s:?T&AnyShape, dir:Float) -> T :
  add-poses(s, [`min-y => pose-mat44f(y3f(y(lo(bounds(s)))), x3f(dir * -90.0f))])
public defn add-max-y-pose<?T> (s:?T&AnyShape, dir:Float) -> T :
  add-poses(s, [`max-y => pose-mat44f(y3f(y(hi(bounds(s)))), x3f(dir *  90.0f))])
public defn add-min-z-pose<?T> (s:?T&AnyShape, dir:Float) -> T :
  add-poses(s, [`min-z => pose-mat44f(z3f(z(lo(bounds(s)))), y3f(180.0f when dir == 1.0f else 0.0f ))])
public defn add-max-z-pose<?T> (s:?T&AnyShape, dir:Float) -> T :
  add-poses(s, [`max-z => pose-mat44f(z3f(z(hi(bounds(s)))), y3f(  0.0f when dir == 1.0f else 180.0f))])

public defn degrees-to-radians (d:Float) -> Float :
  d * to-float(PI-F) / 180.0f

public defn radians-to-degrees (a:Float) -> Float :
  a * 180.0f / to-float(PI-F)

public defn degrees-to-radians (a:V3f) -> V3f :
  V3f(degrees-to-radians(x(a)), degrees-to-radians(y(a)), degrees-to-radians(z(a)))

public defn radians-to-degrees (a:V3f) -> V3f :
  V3f(radians-to-degrees(x(a)), radians-to-degrees(y(a)), radians-to-degrees(z(a)))

public defn rot-x<?T> (d:Float, s:?T&Poseable) -> T :
  xyz(rot-mat44f(V3f(degrees-to-radians(d), 0.0f, 0.0f)), s)

public defn rot-y<?T> (d:Float, s:?T&Poseable) -> T :
  xyz(rot-mat44f(V3f(0.0f, degrees-to-radians(d), 0.0f)), s)

public defn rot-z<?T> (d:Float, s:?T&Poseable) -> T :
  xyz(rot-mat44f(V3f(0.0f, 0.0f, degrees-to-radians(d))), s)

public defn rot<?T> (axis:V3f, ang:Float, s:?T&Poseable) -> T :
  xyz(rot-mat44f(axis, degrees-to-radians(ang)), s)

public defn rot<?T> (axis:V3f, ang:Float, pt:V3f, s:?T&Poseable) -> T :
  val r = rot-mat44f(axis, degrees-to-radians(ang))
  val t = mov-mat44f(pt - (r * pt))
  xyz(r * t, s) 

public defn rot<?T> (a:V3f, b:V3f, s:?T&Poseable) -> T :
  xyz(rot-mat44f(a, b), s)

public defn rot<?T> (a:V2f, b:V2f, s:?T&Poseable) -> T :
  xyz(rot-mat44f(a, b), s)

public defn rot-x (d:Float) : rot-x{d, _}
public defn rot-y (d:Float) : rot-y{d, _}
public defn rot-z (d:Float) : rot-z{d, _}
public defn rot (a:V3f, b:V3f) : rot{a, b, _}
public defn rot (a:V2f, b:V2f) : rot{a, b, _}
public defn rot (axis:V3f, ang:Float) : rot{axis, ang, _}

public defn reflect-x<?T> (s:?T&Poseable) -> T : xyz(mag-mat44f(V3f(-1.0f, 1.0f, 1.0f)), s)
public defn reflect-y<?T> (s:?T&Poseable) -> T : xyz(mag-mat44f(V3f( 1.0f,-1.0f, 1.0f)), s)
public defn reflect-z<?T> (s:?T&Poseable) -> T : xyz(mag-mat44f(V3f( 1.0f, 1.0f,-1.0f)), s)
public defn reflect-xy<?T> (s:?T&Poseable) -> T : xyz(reflect-xy-mat44f(), s)
public defn reflect-xz<?T> (s:?T&Poseable) -> T : xyz(reflect-xz-mat44f(), s)
public defn reflect-yz<?T> (s:?T&Poseable) -> T : xyz(reflect-yz-mat44f(), s)
public defn mag<?T> (fac:Float, s:?T&Poseable) -> T : xyz(mag-mat44f(fac), s)
public defn mag1<?T> (sa:Float, s:?T&Poseable) -> T : xyz(mag-mat44f(sa), s)
public defn mag<?T> (fac:V3f, s:?T&Poseable) -> T : xyz(mag-mat44f(fac), s)
public defn mag-x<?T> (sx:Float, s:?T&Poseable) -> T : xyz(mag-mat44f(V3f(sx, 1.0f, 1.0f)), s)
public defn mag-y<?T> (sy:Float, s:?T&Poseable) -> T : xyz(mag-mat44f(V3f(1.0f, sy, 1.0f)), s)
public defn mag-z<?T> (sz:Float, s:?T&Poseable) -> T : xyz(mag-mat44f(V3f(1.0f, 1.0f, sz)), s)
public defn mag   (s:V3f)    : mag{s, _}
public defn mag1  (s:Float)  : mag-x{s, _}
public defn mag-x (sx:Float) : mag-x{sx, _}
public defn mag-y (sy:Float) : mag-y{sy, _}
public defn mag-z (sz:Float) : mag-z{sz, _}

public defn pose-to-points<?T> (a:V2f, b:V2f, p:?T&Poseable) -> T :
  val v = b - a
  val c = xyz(0.5f * (a + b))
  mov(c, rot(V2f(1.0f, 0.0f), normalize(v), p))

public defn pose-to-points<?T> (a:V3f, b:V3f, p:?T&Poseable) -> T :
  val v = b - a
  val c = 0.5f * (a + b)
  mov(c, rot(V3f(0.0f, 0.0f, 1.0f), v, p))

public defn pose-to-points (a:V2f, b:V2f) : pose-to-points{a, b, _}
public defn pose-to-points (a:V3f, b:V3f) : pose-to-points{a, b, _}

public defn name (a:AnyShape, b:AnyShape) :
  name(a) when name(a) is Symbol else name(b)

public defn tags (a:AnyShape, b:AnyShape) :
  to-tuple $ unique $ cat(tags(a), tags(b))

public defn poses (a:AnyShape, b:AnyShape) :
  to-tuple $ unique $ cat(poses(a), poses(b))

public defn color (a:AnyShape, b:AnyShape) :
  color(a)

public defn dim-min (d:Float) -> Float : d * -0.5f
public defn dim-max (d:Float) -> Float : d *  0.5f

public defn dim-min (dim:V3f) -> V3f : V3f(dim-min(x(dim)), dim-min(y(dim)), dim-min(z(dim)))
public defn dim-max (dim:V3f) -> V3f : V3f(dim-max(x(dim)), dim-max(y(dim)), dim-max(z(dim)))

;;;; SPACE

public defmulti spacer<?T> (g:?T&Poseable, dims:V3f) -> T

;; public defn space-x (gdim:Float, shape:AnyShape) : mag1(gdim / x(dims(bounds(shape))), shape)
;; public defn space-y (gdim:Float, shape:AnyShape) : mag1(gdim / y(dims(bounds(shape))), shape)
;; public defn space-z (gdim:Float, shape:AnyShape) : mag1(gdim / z(dims(bounds(shape))), shape)

public defn spacer-x<?T> (gdim:Float, g:?T&Poseable) : spacer(g, V3f(gdim, 0.0f, 0.0f))
public defn spacer-y<?T> (gdim:Float, g:?T&Poseable) : spacer(g, V3f(0.0f, gdim, 0.0f))
public defn spacer-z<?T> (gdim:Float, g:?T&Poseable) : spacer(g, V3f(0.0f, 0.0f, gdim))

public defn resize-idx<?T> (gdim:Float, idx:Int, shape:?T&AnyShape) -> T :
  mag1(gdim / dims(bounds(shape))[idx], shape)

public defn resize<?T> (gdims:V3f, shape:?T&AnyShape) -> T :
  mag1(min(gdims / dims(bounds(shape))), shape)

public defn resize<?T> (gdims:V2f, shape:?T&AnyShape) -> T :
  mag1(min(gdims / xy(dims(bounds(shape)))), shape)

public defn resize-x<?T> (gdim:Float, shape:?T&AnyShape) -> T : resize-idx(gdim, 0, shape)
public defn resize-y<?T> (gdim:Float, shape:?T&AnyShape) -> T : resize-idx(gdim, 1, shape)
public defn resize-z<?T> (gdim:Float, shape:?T&AnyShape) -> T : resize-idx(gdim, 2, shape)

public defn resize (gdims:V2f) : resize{gdims, _}
public defn resize (gdims:V3f) : resize{gdims, _}
public defn resize-x (gdim:Float) : resize-x{gdim, _}
public defn resize-y (gdim:Float) : resize-y{gdim, _}
public defn resize-z (gdim:Float) : resize-z{gdim, _}

defn area* (dims:V3f) -> Float : dims[max-idx(dims)] * dims[mid-idx(dims)]

public defn remove-spacers (p:Poseable) -> Poseable :
  match(p) :
    (a:Assembly) : Assembly(mat(a), name(a), color(a),
                            seq(remove-spacers, filter({ area*(dims(bounds(_))) > 0.0f }, children(a))))
    (s) : s

public defn stack-idx-using<?T> (ishapes:Seqable<?T&Poseable>, iboundz:Seqable<Box3f>, idx:Int, dir:Float) -> Seq<T> :
  val [shapes, boundz] = [to-tuple(ishapes), to-tuple(iboundz)]
  val tot = sum $ for bounds in boundz seq : dims(bounds)[idx]
  ;; println("TOT %_" % [tot])
  var tot-fac:Float = 0.0f
  val res =
    generate<T&Poseable> :
      for (child in shapes, bounds in boundz) do :
        val now-fac = dims(bounds)[idx] / tot
        val ctr     = center(bounds)[idx]
        val amount  = dir * (tot / 2.0f - (tot-fac + now-fac / 2.0f) * tot) - ctr
        val del     = amount * V3f-unit(idx)
        ;; println("STACKING %_ DEL %_ TOT %_ BOUNDS %_ DIMS %_ VOLUME %_" % [child del tot bounds dims(bounds) volume(dims(bounds))])
        yield(mov(del, child))
        tot-fac = tot-fac + now-fac
  ;; for r in res do :
  ;;   println("STACKED %_ BOUNDS %_ DIMS %_ VOLUME %_" % [r bounds(r) dims(bounds(r)) volume(dims(bounds(r)))])
  ;; val bdz = to-tuple $ seq({ volume(dims(bounds(_))) }, res)
  ;; val rres = to-tuple $ filter({ volume(dims(bounds(_))) > 0.0f }, res)
  ;; println("STACKING RRES %_" % [rres])
  ;; filter({ area*(dims(bounds(_))) > 0.0f }, res)
  res

public defn stack-idx<?T> (ishapes:Seqable<?T&Poseable>, idx:Int, dir:Float) -> Seq<T> :
  val shapes = to-tuple $ ishapes
  stack-idx-using(shapes, seq(bounds, shapes), idx, dir)

public defn stack-x<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-idx(shapes, 0,  -1.0f)

public defn stack-y<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-idx(shapes, 1,  -1.0f)

public defn stack-z<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-idx(shapes, 2,  -1.0f)

public defn stack-meld-idx<?T> (t:Float, ishapes:Seqable<?T&Poseable>, idx:Int, dir:Float) -> Seq<T> :
  val shapes = to-tuple $ ishapes
  defn offset (b:Box3f) :
    val a = -0.5f * t * V3f-unit(idx)
    val res = fatten(b, a)
    ;; println("B %_ T %_ A %_ -> %_" % [b, t, a, res])
    res 
  stack-idx-using(shapes, seq({ offset(bounds(_)) }, shapes), idx, dir)

public defn stack-meld-x<?T> (t:Float, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-meld-idx(t, shapes, 0,  -1.0f)

public defn stack-meld-y<?T> (t:Float, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-meld-idx(t, shapes, 1,  -1.0f)

public defn stack-meld-z<?T> (t:Float, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-meld-idx(t, shapes, 2,  -1.0f)

public defn stack-meld-x (t:Float) : stack-meld-x{t, _}
public defn stack-meld-y (t:Float) : stack-meld-y{t, _}
public defn stack-meld-z (t:Float) : stack-meld-z{t, _}

public deftype AnyGlue <: Poseable
public defmulti amount (g:AnyGlue) -> Float

public defn glue-amount<?T> (shape:?T&Poseable) -> Float :
  match(shape) :
    (g:AnyGlue) : amount(g)
    (s)         : 0.0f

public deftype AssemblyGlue <: AnyGlue & Assembly
public deftype ShapeGlue <: AnyGlue & AnyShape
defmulti glue (g:AssemblyGlue) -> ShapeGlue

public defn AssemblyGlue (glue:ShapeGlue) :
  new AssemblyGlue :
    defmethod glue (this) : glue
    defmethod color (this): BLACK
    defmethod bounds (this) : bounds(glue)
    defmethod amount (this) : amount(glue)

public defmulti glue-of<?T> (s:?T&Poseable, a:Float) -> T

public defn glue-when<?T> (first?:True|False, last?:True|False, ends:Float, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  generate<T> :
    var last-shape:T&Poseable
    for (shape in shapes, i in 0 to false) do :
      if i > 0 :
        yield(glue-of(shape, 1.0f))
      else if first? :
        yield(glue-of(shape, ends))
      yield(shape)
      last-shape = shape
    yield(glue-of(last-shape, ends)) when last? 

public defn glue-even<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  glue-when(true, false, 1.0f, shapes)

public defn glue-odd<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  glue-when(false, false, 1.0f, shapes)

public defn glue-all<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  glue-when(true, true, 1.0f, shapes)

public defn glue-evenly<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  glue-when(true, true, 0.5f, shapes)

public defn glue<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  glue-odd(shapes)

public defn assign-glue-idx<?T> (ishapes:Seqable<?T&Poseable>, target:Float, idx:Int) -> Seq<T> :
  val shapes = to-tuple(ishapes)
  val tot = sum $ for shape in shapes seq : dims(bounds(shape))[idx]
  val glue-tot = sum $ for shape in shapes seq : glue-amount(shape)
  val gap-tot = (target - tot)
  for shape in shapes seq :
    match(shape) :
      (g:AnyGlue&T) :
        val s = (amount(g) / glue-tot) * gap-tot * V3f-unit(idx)
        spacer(shape, s)
      (s)           : s

;; public defn interleave<?T> (a:Seqable<?T&Poseable>, b:Seqable<?T&Poseable>) -> Seq<T> :
;;   generate<T> :
;;     val [sa, sb] = [to-seq(a), to-seq(b)]
;;     let loop (a?:True|False = true) :
;;       if not empty?(sa) and not empty?(sa):
;;         yield(next(sa) when a? else next(sb))
;;         loop(not a?)

public defn stack-idx<?T> (d:Float, idx:Int, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-idx(assign-glue-idx(shapes, d, idx), idx, 1.0f)

public defn stack-x<?T> (w:Float, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-x(assign-glue-idx(shapes, w, 0))
public defn stack-y<?T> (h:Float, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-y(assign-glue-idx(shapes, h, 1))
public defn stack-z<?T> (d:Float, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  stack-z(assign-glue-idx(shapes, d, 2))
public defn stack-x (w:Float) : stack-x{w, _}
public defn stack-y (h:Float) : stack-y{h, _}
public defn stack-z (d:Float) : stack-z{d, _}

public defn space-idx<?T> (iseps:Seqable<Float>, idx:Int, ishapes:Seqable<?T&Poseable>) -> Seq<T> :
  val shapes = to-tuple $ ishapes
  val seps = to-tuple $ for (sep in iseps, i in 0 to (length(shapes) - 1)) seq : sep
  val tot = sum $ seps
  val start = -0.5f * tot
  val offs = to-tuple $ generate<Float> :
    let loop (off = start, i = 0) :
      yield(off)
      if i < length(seps) : loop(off + seps[i], i + 1)
  ;; println("SHAPES %_ SEPS %_ TOT %_ START %_ OFFS %_ DIMZ %_" %
  ;;         [shapes, seps, tot, start, offs, to-tuple $ seq({ dims(bounds(_)) }, shapes)])
  for (shape in shapes, off in offs) seq :
    mov(off * V3f-unit(idx), shape)

public defn space-x<?T> (seps:Seqable<Float>, shapes:Seqable<?T&Poseable>) : space-idx(seps, 0, shapes)
public defn space-y<?T> (seps:Seqable<Float>, shapes:Seqable<?T&Poseable>) : space-idx(seps, 1, shapes)
public defn space-z<?T> (seps:Seqable<Float>, shapes:Seqable<?T&Poseable>) : space-idx(seps, 2, shapes)

public defn space-idx<?T> (sep:Float, idx:Int, shapes:Seqable<?T&Poseable>) -> Seq<T> :
  space-idx(repeatedly({ sep }), idx, shapes)

public defn space-x<?T> (sep:Float, shapes:Seqable<?T&Poseable>) : space-idx(sep, 0, shapes)
public defn space-y<?T> (sep:Float, shapes:Seqable<?T&Poseable>) : space-idx(sep, 1, shapes)
public defn space-z<?T> (sep:Float, shapes:Seqable<?T&Poseable>) : space-idx(sep, 2, shapes)

public defn space-idx (sep:Float, idx:Int) : space-idx{repeatedly({ sep }), idx, _}

public defn space-x (sep:Float) : space-idx(sep, 0)
public defn space-y (sep:Float) : space-idx(sep, 1)
public defn space-z (sep:Float) : space-idx(sep, 2)

defn align-it<?T> (ishapes:Seqable<?T&Poseable>, value:(Box3f) -> Float, mov:(Float, T) -> T) -> Seq<T> :
  val shapes = to-tuple(ishapes)
  val target = reduce(union, seq(bounds, shapes))
  ;; val target = bounds(shapes[0])
  for (child in shapes) seq :
    mov(value(target) - value(bounds(child)), child)

val id-pose = id-mat44f()

public defn attach<?T> (src:?T&Poseable, spos:Mat44f, dst:?T&Poseable, dpos:Mat44f) -> Seqable<T> :
  [xyz(inverse(spos) * dpos, src), dst]

public defn attach<?T> (src:?T&Poseable, si:Symbol, dst:?T&Poseable, di:Symbol) -> Seqable<T> :
  attach(src, lookup?(poses(src),si,id-pose), dst, lookup?(poses(dst),di, id-pose))

public defn align-min-x<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { x(lo(_)) }, mov-x)

public defn align-max-x<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { x(hi(_)) }, mov-x)

public defn align-min-y<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { y(lo(_)) }, mov-y)

public defn align-max-y<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { y(hi(_)) }, mov-y)

public defn align-min-z<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { z(lo(_)) }, mov-z)

public defn align-max-z<?T> (shapes:Seqable<?T&Poseable>) -> Seq<T> :
  align-it(shapes, { z(hi(_)) }, mov-z)

public defn axis-aligned-smash<?T> (s:?T&Poseable) -> T :
  val bb    = bounds(s)
  val dims  = dims(bb)
  val idx   = min-idx(dims)
  val ctr   = center(bb)
  defn rot (s) : if idx == 0 : reflect-xz(s) else if idx == 1 : reflect-yz(s) else : s
  val res = rot(mov((- ctr), s))
  ;; println("SMASH %_ (%_ %_) -> %_" % [s bb ctr res])
  res

defn segment<?T> (shapes:Seqable<?T>, width:T -> Float, max-width:Float, space:Float) -> Seqable<Tuple<T>> :
  val row = Vector<T>()
  generate<Tuple<T>> :
    for pc in shapes do :
      val off = sum $ join(seq(width, cat(row, [pc])), space)
      if off > max-width :
        yield(to-tuple $ row)
        ;; println("OFF %_ > %_" % [off max-width])
        clear(row)
      ;; println("ADD ROW")
      add(row, pc)
    if length(row) > 0 : yield(to-tuple $ row)

public defn nest (pcs:Seqable<Poseable>, size:V2f, spacer:V3f -> Poseable, space:Float) -> Seqable<Assembly> :
  val apcs  = to-tuple $ pcs
  ;; println("NEST A %_" % [apcs])
  val rpcs  = to-tuple $ seq(fn (pc): reflect-xy(pc) when max-idx(dims(bounds(pc))) != max-idx(size) else pc, apcs)
  ;; println("NEST R %_" % [rpcs])
  val spcs  = to-tuple $ lazy-qsort({ y(dims(bounds(_))) }, rpcs)
  ;; println("NEST S %_" % [spcs])
  val rows  = to-tuple $ segment(spcs, { x(dims(bounds(_))) }, x(size), space)
  ;; println("NEST ROWS %_" % [rows])
  ;; val pages = segment(rows, { y(dims(bounds(union(shapes $ Assembly $ _)))) }, y(size), space)
  val pages = to-tuple $ segment(rows, { y(dims(bounds(Assembly $ _))) }, y(size), space)
  ;; println("PAGES %_" % [pages])
  val res = to-tuple $ for page in pages seq :
    val rrows = for row in page seq:
      ;; println("ROW %_" % [row])
      Assembly(stack-x(join(row, spacer(x3f(space)))))
    Assembly(stack-y(join(rrows, Assembly([ spacer(y3f(space)) ]))))
  ;; println("NEST RES %_" % [res])
  res

;;; SHAPE

;; public deftype Shape <: AnyShape
;; 
;; public defn shapes (any-shapes:Seqable<AnyShape>) -> Seqable<Shape> :
;;   generate<Shape> : for e in any-shapes do : yield(e as Shape) when e is Shape
;; 
;; public defn shapes (p:Poseable) : shapes(any-shapes(p))

;;;; AGGREGATE GEOMS

;;; HALF -- PLANE

public defstruct Half :
  normal:   V3f
  distance: Float

public defmethod print (o:OutputStream, g:Half) :
  print-all(o, ["half(" normal(g) "," distance(g) ")"])

public defn half (x:Float, y:Float, z:Float, d:Float) -> Half :
  Half(V3f(x, y, z), d)

public defn half (v:V3f, d:Float) -> Half :
  Half(v, d)

public defn half (p1:V3f, p2:V3f, p3:V3f) -> Half :
  val normal = normalize((p2 - p1) % (p3 - p1))
  val distance = dot(normal, p1)
  Half(normal, distance)

;; defn times (g:Half, m:Mat44f) -> Half :
;;   var dir1:V3f       = V3f(1.0f, 0.0f, 0.0f) % normal(g)
;;   var dir1-len:Float = dot(dir1, dir1)
;;   var tmp:V3f        = V3f(0.0f, 1.0f, 0.0f) % normal(g)
;;   var tmp-len:Float  = dot(tmp, tmp)
;;   if tmp-len > dir1-len :
;;     dir1     = tmp
;;     dir1-len = tmp-len
;;   tmp     = V3f(0.0f,0.0f, 1.0f) % normal(g)
;;   tmp-len = dot(tmp, tmp)
;;   if tmp-len > dir1-len :
;;     dir1     = tmp
;;   val dir2  = dir1 % normal(g)
;;   val point = distance(g) * normal(g)
;;   half(point * m, (point + dir2) * m, (point + dir1) * m)

public defn distance-to (plane:Half, point:V3f) -> Float :
  dot(point, normal(plane)) - distance(plane)

public defn level (g:Half, point:V3f) -> Float :
  (- distance-to(g, point))

val @doc-pose = "POSE -- representing translation and rotation"

public defstruct Pose :
  mov: V3f
  rot: V3f

public defn Pose (mov:V3f) : Pose(mov, V3f(0.0f, 0.0f))
public defn Pose () : Pose(V3f(0.0f, 0.0f))

val id-Pose = Pose()

public defn to-mat44f (p:Pose) -> Mat44f :
  (quat-to-mat44f $ quat-from-euler $ degrees-to-radians $ rot(p)) * mov-mat44f(mov(p))

public defn pose-mat44f (mov:V3f, rot:V3f) -> Mat44f :
  to-mat44f $ Pose(mov, rot) 

public defn pose-mat44f (mov:V3f) : pose-mat44f(mov, V3f(0.0f, 0.0f, 0.0f))


val @doc-mechanism = "MECHANISM -- representing linkage consisting of links, nodes, and joints including top level nodes and root link for modular construction"

public defstruct Mechanism :
  root:Link
  nodes:Tuple<NodeRef>
  links:Tuple<Link>
  joints:Tuple<Joint>
  children:Tuple<Mechanism>

public defn assign-poses (m:Mechanism) :
  defn elaborate (j:Joint) :
    val c0 = connection(j)[0]
    val c1 = connection(j)[1]
    val np = inverse(pose(nodes(link(c1))[node(c1)])) *
             rot-mat44f(V3f(0.0f, 0.0f, 1.0f), degrees-to-radians(state(j))) *
             pose(nodes(link(c0))[node(c0)]) *             
             pose(link(c0))
    set-pose(link(c1), np)
  for joint in joints(m) do :
    elaborate(joint)
  for child in children(m) do :
    assign-poses(child)

public defn all-links (m:Mechanism) :
  cat(links(m), cat-all(seq(all-links, children(m))))

public defn elaborate (m:Mechanism) :
  set-pose(root(m), id-mat44f())
  assign-poses(m)
  group $ seq(fn (l) : xyz(pose(l), geom(l)), all-links(m))  

val @doc-link = "LINK -- single mechanism block with geometry, nodes, and settable pose"

public defstruct Link :
  geom:Poseable
  nodes:Tuple<Node>
  pose:Mat44f with: (setter => set-pose)
  limits:False|Box3f

public defn Link (geom:Poseable, nodes:Tuple<Node>) :
  Link(geom, nodes, id-mat44f(), false)

val @doc-node = "NODE -- link relative pose for placing a joint connecting two links"

public defstruct Node :
  pose:Mat44f

public defn Node (pose:Pose) : Node(to-mat44f $ pose)

val @doc-joint = "JOINT -- z axis revolute constraint between two links at respective nodes with settable angular state"

public defstruct Joint :
  connection:[NodeRef, NodeRef]
  state:Float with: (setter => set-state)
  limits:False|Box1f

public defn Joint (connection:[NodeRef, NodeRef], state:Float) :
  Joint(connection, state, false)

val @doc-noderef = "NODEREF -- link node reference for specifying joint"

public defstruct NodeRef :
  link:Link
  node:Int

;;; LINE

val @doc-line = "LINE -- infinite line"

#for (Line in [Line2f Line2d Line3f Line3d]
      Prim in [Float Double Float Double]
      PrimVec in [V2f V2d V3f V3d]
      One in [1.0f 1.0 1.0f 1.0]
      Zero in [0.0f 0.0 0.0f 0.0]
      Max in [FLOAT-MAX DOUBLE-MAX FLOAT-MAX DOUBLE-MAX]) :

  public defstruct Line <: Geom :
    pos: PrimVec
    dir: PrimVec

  public defn closest-point-to (l:Line, point:PrimVec) -> PrimVec :
    dot((point - pos(l)), dir(l)) * dir(l) + pos(l)

  public defn closest-point-to (l0:Line, l1:Line) -> PrimVec :
    val posLpos = pos(l0) - pos(l1)
    val c = dot(dir(l0), posLpos)
    val a = dot(dir(l1), dir(l0))
    val f = dot(dir(l1), posLpos)
    val num = c - a * f
    val denom = a * a - One
    if abs(denom) < One and abs(num) >= abs(denom) * Max :
      pos(l0)
    else :
      pos(l0) + (num / denom) * dir(l0)

  public defn eval (l:Line, mag:Prim) -> PrimVec :
    pos(l) + mag * dir(l)

  public defn place (l:Line, pt:PrimVec) -> Prim :
    dot(pt - pos(l), dir(l))

  public defn line-of (p0:PrimVec, p1:PrimVec) -> Line :
    Line(p0, normalize(p1 - p0))

  defmethod print (o:OutputStream, l:Line) :
    print(o, "Line(%_, %_)" % [pos(l), dir(l)])

;; public defn extrude (p0:V3f, p1:V3f) -> Half :
;;   val line   = line-of(p0, p1)
;;   val normal = V3f(y(dir(line)), (- x(dir(line))))
;;   val pt     = closest-point-to(line, V3f(0.0f, 0.0f))
;;   val align  = dot(normal, normalize(pt))
;;   ;; println-all(["CLOSEST POINT TO " x(pt) "," y(pt) " NORMAL " x(normal) "," y(normal) " ALIGN " align])
;;   Half(normal, (if align > 0.0f : 1.0f else : -1.0f) * len(pt))

public val EPS = 1.0e-6f

val @doc-implicitline = "IMPLICITLINE -- half space"

public defstruct ImplicitLine :
  a : Float
  b : Float
  c : Float

public defn ImplicitLine (p:V2f, q:V2f) :
  ImplicitLine(y(q) - y(p), x(p) - x(q), x(q) * y(p) - y(q) * x(p))

public defn inside? (l:ImplicitLine, p:V2f) -> True|False :
  (a(l) * x(p) + b(l) * y(p) + c(l)) <= 0.0f

public defn ImplicitLine2 (p:V2f, q:V2f) :
  val t = q - p
  val len = magnitude(t)
  val a = y(t) / len
  val b = (- x(t)) / len
  val c = -0.5f * ((a * x(p) + b * y(p)) + (a * x(q) + b * y(q)))
  ImplicitLine(a, b, c)

public defn eval (l:ImplicitLine, p:V2f) -> Float :
  a(l) * x(p) + b(l) * y(p) + c(l)
  
public defn intersect (l:ImplicitLine, p1:V2f, p2:V2f) -> V2f :
  ;; assumes that segment (p1, p2) crosses the line
  val d = p2 - p1
  val t = (- eval(l, p1)) / (a(l) * x(d) + b(l) * y(d))
  p1 + t * d

public defn classify (l:ImplicitLine, p:V2f) -> Int :
  val d = eval(l, p)
  -1 when (d < (- EPS)) else (1 when (d > EPS) else 0)

public defn on? (l:ImplicitLine, p:V2f) -> True|False :
  val tmp = eval(l, p)
  abs(tmp) <= EPS

public defn left? (l:ImplicitLine, p:V2f) -> True|False :
  eval(l, p) < (- EPS)

val @doc-triangle = "TRIANGLE -- using intersecting half spaces"

public defstruct Triangle <: Geom :
  vertices : Tuple<V2f>
  lines : Tuple<ImplicitLine>

defmethod print (o:OutputStream, t:Triangle) :
  print(o, "Triangle(%_)" % [vertices(t)])

public defn Triangle (ipts:Tuple<V2f>) :
  val order = xyz(ipts[1] - ipts[0]) % xyz(ipts[2] - ipts[0])
  val pts = ipts when z(order) >= 0.0f else [ ipts[0] ipts[2] ipts[1] ]
  val lines = for i in 0 to 3 seq : ImplicitLine(pts[i], pts[(i + 1) % 3])
  Triangle(pts, to-tuple $ lines)

public defn inside? (l:Triangle, p:V2f) -> True|False :
  inside?(lines(l)[0], p) and inside?(lines(l)[1], p) and inside?(lines(l)[2], p)

public defn bounds (t:Triangle) : reduce(union, seq(Box2f, vertices(t)))

public defstruct Triangle2i :
  a:V2i
  b:V2i
  c:V2i

public defmethod print (o:OutputStream, t:Triangle2i) :
  print(o, "Triangle2i(%_ %_ %_)" % [a(t) b(t) c(t)])

;;; LINESEGMENT

val @doc-linesegment = "LINESEGMENT -- line between two points"

#for (Prim in [Float Float]
      Vec in [V2f V3f]
      LineSegment in [LineSegment2f LineSegment3f]
      Box in [Box2f Box3f]
      LineSegmentName in ["LineSegment2f" "LineSegment3f"]) :

  public defstruct LineSegment <: Geom :
    start: Vec
    end:   Vec

  public defn center (l:LineSegment) -> Vec :
    0.5f * (start(l) + end(l))

  public defn vector (l:LineSegment) -> Vec :
    end(l) - start(l)

  public defn magnitude (l:LineSegment) -> Prim :
    magnitude(vector(l))

  defmethod print (o:OutputStream, l:LineSegment) :
    print(o, "%_(%_ %_)" % [LineSegmentName start(l) end(l)])

public defn intersects? (a:LineSegment2f, b:LineSegment2f) -> True|False :
  val [p, r] = [start(a), end(a) - start(a)]
  val [q, s] = [start(b), end(b) - start(b)]
  val r%s = r % s
  val q-p = q - p
  val q-p%r = q-p % r
  val q-p%s = q-p % s
  if r%s == 0.0f :
    if q-p%r == 0.0f :
      val t0 = dot(q-p, r) / dot(r, r)
      val t1 = t0 + dot(s, r) / dot(r, r)
      val bx = Box1f(t0) | Box1f(t1)
      lo(bx) >= 0.0f and hi(bx) <= 1.0f
    else :
      false
  else :
    val t = (q-p % s) / r%s
    val u = (q-p % r) / r%s
    t >= 0.0f and t <= 1.0f and u >= 0.0f and u <= 1.0f 

;;; CONTOUR

val @doc-contour = "CONTOUR -- closed paths"

public defstruct Contour <: Geom&Equalable :
  vertices: Tuple<V2f>

defmethod equal? (a:Contour, b:Contour) -> True|False :
  vertices(a) == vertices(b)

public defn bounds (c:Contour) -> Box3f :
  reduce(union, neg-inf-box3f(), seq(Box3f{xyz(_)}, vertices(c)))

defmethod print (o:OutputStream, c:Contour) :
  val pv = to-tuple(vertices(c)[0 to 100]) when length(vertices(c)) > 100 else vertices(c)
  print(o, "Contour([%,])" % [pv])

public var *line-width* = 0.001
public defn set-line-width (x:Float) : *line-width* = x

defn do-print-svg (s:OutputStream, color:V4f, points:Seqable<V2f>, close?:True|False) :
  print(s, "<path d=\"")
  for (p in points, i in 0 to false) do :  
    print-all(s, [" " ("M" when i == 0 else "L") " " x(p) " " y(p)])
  print(s, " %_\" fill=\"none\" stroke=\"rgb(%_%%, %_%%, %_%%)\" stroke-width=\"%_\"/>" %
           [("Z " when close? else "") 100.0f * x(color), 100.0f * y(color), 100.0f * z(color), *line-width*])

defn do-print-svg (s:OutputStream, color:V4f, contour:Contour) :
  do-print-svg(s, color, vertices(contour), true)

public defn times (mat:Mat44f, p:Contour) -> Contour :
  Contour(for p in vertices(p) map : mat * p)

public defn to-stroke (contour:Contour) -> Tuple<V2f> :
  to-tuple $ cat(vertices(contour), [ vertices(contour)[0] ])

public defn segments (contour:Contour) -> Seq<LineSegment2f> :
  val pts = vertices(contour)
  for i in 0 to length(pts) seq :
    LineSegment2f(pts[i], pts[(i + 1) % length(pts)])

public defn area (verts:Tuple<V2f>) -> Float :
  val a = sum $ for i in 1 to (length(verts) + 1) seq :
    val [p1, p2] = [verts[i - 1], verts[i % length(verts)]]
    x(p1) * y(p2) - x(p2) * y(p1)
  ;; println("AREA %_ -> %_" % [verts, a])
  a

public defn area (contour:Contour) -> Float :
  area(vertices(contour))

public defn area (polygon:Polygon) -> Float :
  sum $ seq(area, contours(polygon))

;; ;;; STROKE
;; 
;; public defstruct Stroke <: Geom :
;;   points: Tuple<V2f>
;; 
;; defmethod print (o:OutputStream, c:Stroke) :
;;   print("Stroke(%,)" % [points(c)])
;; 
;; public defn times (mat:Mat44f, p:Stroke) -> Stroke :
;;   Stroke(for p in points(p) map : mat * p)

;;; POLYGON

defn default-anyshape-state () : AnyShapeState(false, WHITE, [], [])

val @doc-polygon = "POLYGON -- list of contours"

public defstruct Polygon <: AnyShape&Equalable :
  state: AnyShapeState with: (as-method => true)
  contours: Tuple<Contour>

defmethod equal? (a:Polygon, b:Polygon) -> True|False :
  contours(a) == contours(b)

public defn Polygon (contours:Seqable<Contour>) :
  Polygon(default-anyshape-state(), to-tuple $ contours)

public defn get (p:Polygon, i:Int) -> Contour : contours(p)[i]
public defn get (c:Contour, i:Int) -> V2f : vertices(c)[i]

public defn polygon-n (d:Float, n:Int) -> Polygon :
  val r = 0.5f * d
  val points = 
    for i in 0 to n seq :
      val a = to-float(i) * 2.0f * PI-F / to-float(n)
      V2f(r * sin(a), r * cos(a))
  to-polygon(Contour(to-tuple(points)))

public defn polygon-rect (dims:V2f) -> Polygon :
  to-polygon(Contour(to-tuple(corners(dims-to-box(dims)))))

defmethod spacer (g:Polygon, gdims:V3f) :
  polygon-rect(xy(gdims))

public defn to-polygon (c:Contour) -> Polygon :
  Polygon([c])

public defn to-polygon (b:Box2f) -> Polygon :
  to-polygon $ Contour $ corners(b)

public defn to-polyline (p:Polygon) -> PolyLine2f :
  PolyLine2f(to-tuple $ seq(to-stroke, contours(p)))

defmethod clone (poly:Polygon, state:AnyShapeState) -> Polygon :
  Polygon(state, contours(poly))

public defmethod bounds (p:Polygon) -> Box3f :
  reduce(union, neg-inf-box3f(), seq(bounds, contours(p)))

defmethod xyz (mat:Mat44f, poly:Polygon) -> Polygon :
  Polygon(state(poly), to-tuple $ for c in contours(poly) map : mat * c)

public defn to-v2f (vals:Seqable<Float>) -> V2f :
  val elts = to-tuple $ vals
  V2f(elts[0], elts[1])
  
public defn Polygon (cs:Seqable<Seqable<V2f>>) -> Polygon :
  Polygon(to-tuple $ seq(Contour, seq(to-tuple, cs)))

public defn vertices (p:Polygon) -> Tuple<V2f> :
  to-tuple $ cat-all(for c in contours(p) seq : vertices(c))

public defn segments (polygon:Polygon) -> Seq<LineSegment2f> :
  cat-all(seq(segments, contours(polygon)))

public defn perimeter (polygon:Polygon) -> Float :
  sum $ seq(magnitude, segments(polygon))

public defn cat (p1:Polygon, p2:Polygon) -> Polygon :
  Polygon(cat(contours(p1), contours(p2)))

defmethod print (o:OutputStream, c:Polygon) :
  print(o, "Polygon([%,])" % [contours(c)])

defn do-print-svg-header (s:OutputStream, bounds:Box2f, f:OutputStream -> False) :
  println-all(s, ["<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>"])
  println-all(s, ["<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\""])
  println-all(s, [" width=\"" x(dims(bounds)) "\" height=\"" y(dims(bounds)) "\" id=\"cons\">"])
  f(s)
  println(s, "\n</svg>")

defn do-print-svg (s:OutputStream, polygon:Polygon) :
  for c in contours(polygon) do :
    do-print-svg(s, color(polygon), c)

;;; POLYLINE

val @doc-polyline = "POLYLINE -- lists of open paths called strokes"

#for (Prim in [Float Float]
      Vec in [V2f V3f]
      PolyLine in [PolyLine2f PolyLine3f]
      LineSegment in [LineSegment2f LineSegment3f]
      Box in [Box2f Box3f]
      neg-inf-box in [neg-inf-box2f neg-inf-box3f]
      PolyLineName in ["PolyLine2f" "PolyLine3f"]) :

  public defstruct PolyLine <: AnyShape&Equalable :
    state: AnyShapeState with: (as-method => true)
    ;; strokes: Tuple<Stroke>
    strokes: Tuple<Tuple<Vec>>

  defmethod equal? (a:PolyLine, b:PolyLine) -> True|False :
    strokes(a) == strokes(b)

  public defn PolyLine (strokes:Seqable<Tuple<Vec>>) :
    PolyLine(default-anyshape-state(), to-tuple $ strokes)

  defmethod clone (poly:PolyLine, state:AnyShapeState) -> PolyLine :
    PolyLine(state, strokes(poly))

  defmethod xyz (mat:Mat44f, poly:PolyLine) -> PolyLine :
    PolyLine(state(poly), for s in strokes(poly) map : for v in s map : mat * v)

  defmethod print (o:OutputStream, c:PolyLine) :
    print(o, "%_(%_)" % [PolyLineName strokes(c)])

  defmethod bounds (p:PolyLine) -> Box3f :
    val boxes = seq(reduce{union, neg-inf-box(), seq(Box, _)}, strokes(p))
    xyz(reduce(union, neg-inf-box(), boxes))

  public defmethod bit-or (a:PolyLine, b:PolyLine) -> PolyLine :
    PolyLine(state(a) | state(b), to-tuple $ cat(strokes(a), strokes(b)))
    
  public defn cat (p1:PolyLine, p2:PolyLine) -> PolyLine :
    PolyLine(cat(strokes(p1), strokes(p2)))

  public defn segments (polyline:PolyLine) -> Seq<LineSegment> :
    generate<LineSegment> :
      for s in strokes(polyline) do :
        for i in 0 to (length(s) - 1) do :
          yield(LineSegment(s[i], s[i + 1]))

  public defn perimeter (polyline:PolyLine) -> Float :
    sum $ seq(magnitude, segments(polyline))

defn do-print-svg (s:OutputStream, polyline:PolyLine2f) :
  for line in strokes(polyline) do :
    do-print-svg(s, color(polyline), line, false)

defn svg (s:OutputStream, g:Assembly|PolyLine2f|Polygon, bbox:Box2f) :
  do-print-svg-header(s, bbox, {
    val mg = mov(xyz(-1.0f * lo(bbox)), g)
    do-print-svg(s, mg) })

public defn svg (g:Assembly|PolyLine2f|Polygon, filename:String, bbox:Box2f) :
  val s = FileOutputStream(filename)
  try : svg(s, g, bbox)
  finally : close(s)

public defn svg (g:Assembly|PolyLine2f|Polygon, filename:String, margin:V2f) :
  svg(g, filename, fatten(xy(bounds(g)), margin))

public defn to-polyline2f (g:PolyLine3f) -> PolyLine2f :
  val stks = for s in strokes(g) seq : to-tuple(seq(xy, s))
  PolyLine2f(to-tuple(stks))

public defn to-polyline2f (g:Polygon) -> PolyLine2f :
  val stks = for c in contours(g) seq : to-tuple(cat(vertices(c), [vertices(c)[0]]))
  PolyLine2f(to-tuple(stks))

public defn to-polyline2f (ls:Seqable<LineSegment2f>) -> PolyLine2f :
  PolyLine2f $ to-tuple $ seq(fn (s) : [start(s), end(s)], ls)

public defn to-polygon (g:PolyLine2f) -> Polygon :
  val cts = for s in strokes(g) seq : Contour(to-tuple(s[0 to length(s) - 1]))
  Polygon(to-tuple(cts))

public defn to-polyline3f (g:PolyLine2f) -> PolyLine3f :
  val stks = for s in strokes(g) seq : to-tuple(seq(xyz, s))
  PolyLine3f(to-tuple(stks))

public defn cubic-interpolate (y0:Float, y1:Float, y2:Float, y3:Float, mu:Float) -> Float :
  val mu2 = mu * mu
  val a0 = -0.5f * y0 + 1.5f * y1 - 1.5f * y2 + 0.5f * y3
  val a1 = y0 - 2.5f * y1 + 2.0f * y2 - 0.5f * y3
  val a2 = -0.5f * y0 + 0.5f * y2
  val a3 = y1
  a0 * mu * mu2 + a1 * mu2 + a2 * mu + a3

public defn cubic-interpolate (p0:V2f, p1:V2f, p2:V2f, p3:V2f, mu:Float) -> V2f :
  V2f(cubic-interpolate(x(p0), x(p1), x(p2), x(p3), mu),
      cubic-interpolate(y(p0), y(p1), y(p2), y(p3), mu))

public defn cubic-interpolate (l:Tuple<V2f>, n:Int) -> Seqable<V2f> :
  val len = length(l)
  val pts = for i in 0 to (len - 1) seq-cat :
    val p0 = l[0]     when i ==         0 else l[i - 1]
    val p3 = l[i + 1] when i == (len - 2) else l[i + 2]
    for j in 0 to n seq :
      val mu = to-float(j) / to-float(n)
      cubic-interpolate(p0, l[i], l[i + 1], p3, mu)
  cat(pts, [last(l)])

public defn cubic-interpolate-wrapped (l:Tuple<V2f>, n:Int) -> Seqable<V2f> :
  val len = length(l)
  val pts = to-tuple $ for i in 0 to len seq-cat :
    val p0 = l[(i - 1 + len) % len]
    val p3 = l[(i + 2)       % len]
    for j in 0 to n seq :
      val mu = to-float(j) / to-float(n)
      cubic-interpolate(p0, l[i], l[(i + 1) % len], p3, mu)
  cat(pts, [pts[0]])

;;; MESH
 
val @doc-mesh = "MESH -- triangulated surfaces"

public defstruct Mesh <: AnyShape&Equalable :
  state: AnyShapeState with: (as-method => true)
  vertices: Tuple<V3f>
  faces:    Tuple<V3i>

defmethod equal? (a:Mesh, b:Mesh) -> True|False :
  vertices(a) == vertices(b) and faces(a) == faces(b)

public defn Mesh (vertices:Tuple<V3f>, faces:Tuple<V3i>) :
  Mesh(default-anyshape-state(), vertices, faces)

defmethod clone (mesh:Mesh, state:AnyShapeState) -> Mesh :
  Mesh(state, vertices(mesh), faces(mesh))

defmethod xyz (mat:Mat44f, mesh:Mesh) -> Mesh :
  Mesh(state(mesh), to-tuple $ for v in vertices(mesh) seq : mat * v, faces(mesh))

defmethod bounds (p:Mesh) -> Box3f :
  reduce(union, neg-inf-box3f(), seq(Box3f, vertices(p)))

defmethod bit-or (a:Mesh, b:Mesh) -> Mesh :
  val b-faces = for face in faces(b) seq : face + xyz(length(faces(a)))  
  Mesh(state(a) | state(b), to-tuple $ cat(vertices(a), vertices(b)), to-tuple $ cat(faces(a), b-faces))
    
defmethod print (o:OutputStream, m:Mesh) :
  print-all(o, ["Mesh(" vertices(m) "," faces(m) ")"])

public defn triangle-area (verts:Tuple<V3f>) -> Float :
  val ls = to-tuple $ for i in 1 to 4 seq : distance(verts[i - 1], verts[i % 3])
  val p  = (sum $ ls) / 2.0f
  p * product $ for l in ls seq : (p - l)

public defn surface-area (m:Mesh) -> Float :
  val verts = vertices(m)
  defn face-area (face:V3i) -> Float :
    triangle-area $ [verts[x(face)], verts[y(face)], verts[z(face)]]
  abs $ sum $ seq(face-area, faces(m))

;; ;; public defn triangulate (p: Polygon) :
;; ;;   val vertices = Vector<V3f>()
;; ;;   val faces  = Vector<Int>()
;; ;; 
;; ;;   defn vertex-callback (index: Int) :
;; ;;     ;; println("Vertex Callback")
;; ;;     add(faces, index)
;; ;; 
;; ;;   defn combine-callback (x:Float, y:Float, z:Float) -> Int :
;; ;;     ;; println("Combine Callback")
;; ;;     add(vertices, V3f(x, y, z))
;; ;;     length(vertices) - 1
;; ;; 
;; ;;   val tess-ptr = call-c(triangulator_new, vertex-callback, combine-callback)
;; ;; 
;; ;;   call-c(triangulator_begin_polygon, tess-ptr)
;; ;;   for c in contours(p) do :
;; ;;     call-c(triangulator_begin_contour, tess-ptr)
;; ;;     for p in points(c) do :
;; ;;       add(vertices, p)
;; ;;       call-c(triangulator_vertex, tess-ptr, length(vertices) - 1, x(p), y(p), z(p))
;; ;;     call-c(triangulator_end_contour, tess-ptr)
;; ;;   call-c(triangulator_end_polygon, tess-ptr)
;; ;; 
;; ;;   Mesh(vertices, faces)

val @doc-shape = "SHAPE -- a solid object"

public deftype Shape <: AnyShape

public defn shapes (any-shapes:Seqable<AnyShape>) -> Seqable<Shape> :
  generate<Shape> : for e in any-shapes do : yield(e as Shape) when e is Shape and area*(dims(bounds(e))) > 0.0f

public defn shapes (p:Poseable) : shapes(any-shapes(p))

public var *resolution* = 8.0f
public defn set-resolution (r:Float) : *resolution* = r

;; public defmulti slice (z:Float, s:Shape3) -> Shape2
;; public defmulti pixels (z:Float, s:Shape3) -> Pixels
;; public defmulti box (b:Box3f) -> Shape3
;; public defmulti cube (v:V3f) -> Shape3
;; 
;; public defmulti rect (b:Box2f) -> Shape2
;; public defmulti circle (d:Float) -> Shape2
;; public defmulti triangle (a:V2f, b:V2f, c:V2f) -> Shape2
;; public defmulti extrude (h:Float, shape:Shape2) -> Shape3
;; 
;; public defmulti bit-and (a:Shape3, b:Shape3) -> Shape3
;; public defmulti rem (a:Shape3, b:Shape3) -> Shape3
;; public defmulti offset (s:Shape3, o:Float) -> Shape3

public defmulti shape-eval (e) -> Geom
