;; See license.txt for details about licensing.

defpackage geom:
  import core
  import math
  import collections
  import utils

public deftype Geom

public defstruct Msg <: Geom :
  value : String

public defn ensure-index-in-bounds (i:Int, n:Int) :
   if i < 0 or i >= n :
      fatal("Index (%_) out of bounds." % [i])

;;; VECS

public lostanza deftype Vf <: Array<Float> & Geom :
  length: long
  elts:   float ...

public lostanza defn Vf (n:ref<Int>, x:ref<Float>) -> ref<Vf> :
  #if-not-defined(OPTIMIZE) :
    ensure-non-negative-length(n)
  val l = n.value
  val a = new Vf{l}
  val c = x.value
  for (var i:long = 0, i < l, i = i + 1) :
    a.elts[i] = c
  return a

public defn Vf (n:Int) -> Vf :
  Vf(n, 0.0f)

lostanza defn vf-get (v:ref<Vf>, i:ref<Int>) -> ref<Float> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, length(v))
  return new Float{v.elts[i.value]}
  
lostanza defn vf-set (v:ref<Vf>, i:ref<Int>, x:ref<Float>) -> ref<False> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, length(v))
  v.elts[i.value] = x.value
  return false
  
lostanza defn vf-length (v:ref<Vf>) -> ref<Int> :
  return new Int{v.length as int}
  
defmethod get (a:Vf, i:Int) -> Float : vf-get(a, i)
defmethod set (a:Vf, i:Int, c:Float) -> False : vf-set(a, i, c)
defmethod length (a:Vf) -> Int : vf-length(a)

defmethod print (o:OutputStream, v:Vf) :
  print-all(o, ["Vf(" length(v) ")"])

public lostanza deftype Vi <: Array<Int> & Geom :
  length: long
  elts:   int ...

public lostanza defn Vi (n:ref<Int>, x:ref<Int>) -> ref<Vi> :
  #if-not-defined(OPTIMIZE) :
    ensure-non-negative-length(n)
  val l = n.value
  val a = new Vi{l}
  val c = x.value
  for (var i:long = 0, i < l, i = i + 1) :
    a.elts[i] = c
  return a

public defn Vi (n:Int) -> Vi :
  Vi(n, 0)

lostanza defn vi-get (v:ref<Vi>, i:ref<Int>) -> ref<Int> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, length(v))
  return new Int{v.elts[i.value]}
  
lostanza defn vi-set (v:ref<Vi>, i:ref<Int>, x:ref<Int>) -> ref<False> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, length(v))
  v.elts[i.value] = x.value
  return false
  
lostanza defn vi-length (v:ref<Vi>) -> ref<Int> :
  return new Int{v.length as int}
  
defmethod get (a:Vi, i:Int) -> Int : vi-get(a, i)
defmethod set (a:Vi, i:Int, c:Int) -> False : vi-set(a, i, c)
defmethod length (a:Vi) -> Int : vi-length(a)

defmethod print (o:OutputStream, v:Vi) :
  print-all(o, ["Vi(" length(v) ")"])

;;; V3i

;; public defstruct V3i <: Array<Int> :
;;   x : Int
;;   y : Int
;;   z : Int

public lostanza deftype V3i <: Array<Int> & Hashable & Geom :
  x: int
  y: int
  z: int

public lostanza defn V3i (x:ref<Int>, y:ref<Int>, z:ref<Int>) -> ref<V3i> :
  return new V3i{x.value, y.value, z.value}

public lostanza defn x (v:ref<V3i>) -> ref<Int> :
  return new Int{v.x}

public lostanza defn y (v:ref<V3i>) -> ref<Int> :
  return new Int{v.y}

public lostanza defn z (v:ref<V3i>) -> ref<Int> :
  return new Int{v.z}

public defn V3i (x:Int, y:Int) -> V3i :
  V3i(x, y, 0)

public defn to-v3i (v:V3f) -> V3i :
  V3i(to-int(x(v)), to-int(y(v)), to-int(z(v)))

public defn round (p:V3f) -> V3f :
  V3f(round(x(p)), round(y(p)), round(z(p)))

public defn to-v3f (v:V3i) -> V3f :
  V3f(to-float(x(v)), to-float(y(v)), to-float(z(v)))

public lostanza defn v3i-get (v:ref<V3i>, i:ref<Int>) -> ref<Int> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, new Int{3})
  return new Int{addr!(v.x)[i.value]}
  
defmethod get (a:V3i, i:Int) -> Int : v3i-get(a, i)

defmethod length (a:V3i) -> Int : 3

defmethod equal? (v1:V3i, v2:V3i) :
  x(v1) == x(v2) and y(v1) == y(v2) and z(v1) == z(v2) 

defmethod hash (v:V3i) :
  (7 * ((7 * hash(x(v))) + hash(y(v)))) + hash(z(v))

public defn xy (p:V3i) -> V3i :
  V3i(x(p), y(p), 0)

defmethod print (o:OutputStream, v:V3i) :
  print-all(o, ["V3i(", x(v), ",", y(v), ",", z(v), ")"])

public defn dot (a:V3i, b:V3i) -> Int :
  x(a) * x(b) + y(a) * y(b) + z(a) * z(b)

public defn min (a:V3i) -> Int :
  min(x(a), min(y(a), z(a)))

public defn max (a:V3i) -> Int :
  max(x(a), max(y(a), z(a)))

public defn min (a:V3i, b:V3i) -> V3i :
  V3i(min(x(a), x(b)), min(y(a), y(b)), min(z(a), z(b)))

public defn max (a:V3i, b:V3i) -> V3i :
  V3i(max(x(a), x(b)), max(y(a), y(b)), max(z(a), z(b)))

public defn times (a:Int, b:V3i) -> V3i :
  V3i(a * x(b), a * y(b), a * z(b))

public defn divide (a:V3i, b:Int) -> V3i :
  V3i(x(a) / b, y(a) / b, z(a) / b)

public defn plus (a:V3i, b:V3i) -> V3i :
  V3i(x(a) + x(b), y(a) + y(b), z(a) + z(b))

public defn minus (a:V3i, b:V3i) -> V3i :
  V3i(x(a) - x(b), y(a) - y(b), z(a) - z(b))

public defn negate (a:V3i) -> V3i :
  V3i((- x(a)), (- y(a)), (- z(a)))

;;; Interval 

public lostanza deftype Interval <: Geom & Equalable :
  lo: float
  hi: float

public lostanza defn Interval (lo:ref<Float>, hi:ref<Float>) -> ref<Interval> :
  return new Interval{lo.value, hi.value}

public lostanza defn lo (i:ref<Interval>) -> ref<Float> :
  return new Float{i.lo}

public lostanza defn hi (i:ref<Interval>) -> ref<Float> :
  return new Float{i.hi}

defmethod equal? (i1:Interval, i2:Interval) :
  lo(i1) == lo(i2) and hi(i1) == hi(i2)

defmethod print (o:OutputStream, i:Interval) :
  print-all(o, ["Interval(", lo(i), ",", hi(i) ")"])

;;; V3f

;; public defstruct V3f <: Array<Float> :
;;   x: Float
;;   y: Float
;;   z: Float

public lostanza deftype V3f <: Array<Float> & Geom & Hashable & Equalable :
  x: float
  y: float
  z: float

public lostanza defn V3f (x:ref<Float>, y:ref<Float>, z:ref<Float>) -> ref<V3f> :
  return new V3f{x.value, y.value, z.value}

public defn V2f (x:Float, y:Float) -> V3f :
  V3f(x, y, 0.0f)

public defn V3f-fill (a:Float) : V3f(a, a, a)

public defn V3f-unit (i:Int) :
  if i == 0 :      V3f(1.0f, 0.0f, 0.0f)
  else if i == 1 : V3f(0.0f, 1.0f, 0.0f)
  else :           V3f(0.0f, 0.0f, 1.0f)
  
public defn set-elt (v:V3f, i:Int, a:Float) -> V3f :
  V3f(a when i == 0 else v[0], a when i == 1 else v[1], a when i == 2 else v[2])

public lostanza defn x (v:ref<V3f>) -> ref<Float> :
  return new Float{v.x}

public lostanza defn y (v:ref<V3f>) -> ref<Float> :
  return new Float{v.y}

public lostanza defn z (v:ref<V3f>) -> ref<Float> :
  return new Float{v.z}

public lostanza defn v3f-get (v:ref<V3f>, i:ref<Int>) -> ref<Float> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, new Int{3})
  return new Float{addr!(v.x)[i.value]}
  
public defmethod get (a:V3f, i:Int) -> Float : v3f-get(a, i)

public defn max-idx (v:V3f) -> Int :
  if x(v) > y(v):
    if x(v) > z(v): 0 else: 2
  else:
    if y(v) > z(v): 1 else: 2

public defn min-idx (v:V3f) -> Int :
  if x(v) < y(v):
    if x(v) < z(v): 0 else: 2
  else:
    if y(v) < z(v): 1 else: 2

;; public defmethod get (a:V3f, i:Int) -> Float :
;;   if i == 0 : x(a) 
;;   else if i == 1 : y(a) 
;;   else : z(a) 

public defmethod length (a:V3f) -> Int : 3

defmethod equal? (v1:V3f, v2:V3f) :
  x(v1) == x(v2) and y(v1) == y(v2) and z(v1) == z(v2) 

defmethod hash (v:V3f) :
  (7 * ((7 * hash(x(v))) + hash(y(v)))) + hash(z(v))

defmethod print (o:OutputStream, v:V3f) :
  print-all(o, ["V3f(", x(v), "f,", y(v), "f,", z(v), "f)"])

public defn dot (a:V3f, b:V3f) -> Float :
  x(a) * x(b) + y(a) * y(b) + z(a) * z(b)

public defn xy (p:V3f) -> V3f :
  V3f(x(p), y(p), 0.0f)

public defn min (a:V3f) -> Float :
  min(x(a), min(y(a), z(a)))

public defn max (a:V3f) -> Float :
  max(x(a), max(y(a), z(a)))

public defn abs (a:V3f) -> V3f :
  V3f(abs(x(a)), abs(y(a)), abs(z(a)))

public defn min (a:V3f, b:V3f) -> V3f :
  V3f(min(x(a), x(b)), min(y(a), y(b)), min(z(a), z(b)))

public defn max (a:V3f, b:V3f) -> V3f :
  V3f(max(x(a), x(b)), max(y(a), y(b)), max(z(a), z(b)))

public defn volume (a:V3f) -> Float :
  x(a) * y(a) * z(a)

public defn area (a:V3f) -> Float :
  x(a) * y(a)

public defn magnitude (a:V3f) -> Float :
  sqrt(dot(a, a))

public defn distance (v0:V3f, v1:V3f) -> Float :
  magnitude(v1 - v0)

public defn normalize (a:V3f) -> V3f :
  a / magnitude(a)

public defn times (a:Float, b:V3f) -> V3f :
  V3f(a * x(b), a * y(b), a * z(b))

public defn times (a:V3f, b:V3f) -> V3f :
  V3f(x(a) * x(b), y(a) * y(b), z(a) * z(b))

public defn divide (a:V3f, b:Float) -> V3f :
  V3f(x(a) / b, y(a) / b, z(a) / b)

public defn divide (a:V3f, b:V3f) -> V3f :
  V3f(x(a) / x(b), y(a) / y(b), z(a) / z(b))

public defn plus (a:V3f, b:V3f) -> V3f :
  V3f(x(a) + x(b), y(a) + y(b), z(a) + z(b))

public defn minus (a:V3f, b:V3f) -> V3f :
  V3f(x(a) - x(b), y(a) - y(b), z(a) - z(b))

public defn modulo (a:V3f, b:V3f) -> V3f :
  V3f(y(a) * z(b) - z(a) * y(b),
      z(a) * x(b) - x(a) * z(b),
      x(a) * y(b) - y(a) * x(b))

public defn negate (a:V3f) -> V3f :
  V3f((- x(a)), (- y(a)), (- z(a)))

;;; V4f

;; public defstruct V4f <: Array<Float> :
;;   x: Float
;;   y: Float
;;   z: Float
;;   a: Float

public lostanza deftype V4f <: Array<Float> & Geom & Hashable :
  x: float
  y: float
  z: float
  a: float

public lostanza defn V4f (x:ref<Float>, y:ref<Float>, z:ref<Float>, a:ref<Float>) -> ref<V4f> :
  return new V4f{x.value, y.value, z.value, a.value}

public lostanza defn x (v:ref<V4f>) -> ref<Float> :
  return new Float{v.x}

public lostanza defn y (v:ref<V4f>) -> ref<Float> :
  return new Float{v.y}

public lostanza defn z (v:ref<V4f>) -> ref<Float> :
  return new Float{v.z}

public lostanza defn a (v:ref<V4f>) -> ref<Float> :
  return new Float{v.a}

public defn V4f (x:Float, y:Float, z:Float) -> V4f :
  V4f(x, y, z, 0.0f)

public lostanza defn v4f-get (v:ref<V4f>, i:ref<Int>) -> ref<Float> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, new Int{3})
  return new Float{addr!(v.x)[i.value]}
  
public defmethod get (a:V4f, i:Int) -> Float : v4f-get(a, i)

public defmethod length (a:V4f) -> Int : 4

defmethod equal? (v1:V4f, v2:V4f) :
  x(v1) == x(v2) and y(v1) == y(v2) and z(v1) == z(v2) and a(v1) == a(v2) 

defmethod hash (v:V4f) :
  (7 * ((7 * ((7 * hash(x(v))) + hash(y(v)))) + hash(z(v)))) + hash(a(v))

defmethod print (o:OutputStream, v:V4f) :
  print-all(o, ["V4f(", x(v) "," y(v) "," z(v) "," a(v) ")"])

public val RED   = V4f(1.0f, 0.0f, 0.0f, 1.0f)
public val GREEN = V4f(0.0f, 1.0f, 0.0f, 1.0f)
public val BLUE  = V4f(0.0f, 0.0f, 1.0f, 1.0f)
public val BLACK  = V4f(0.0f, 0.0f, 0.0f, 1.0f)
public val WHITE  = V4f(1.0f, 1.0f, 1.0f, 1.0f)

;;; V3d

public lostanza deftype V3d <: Array<Double> & Geom & Hashable :
  x: double
  y: double
  z: double

public lostanza defn V3d (x:ref<Double>, y:ref<Double>, z:ref<Double>) -> ref<V3d> :
  return new V3d{x.value, y.value, z.value}

public lostanza defn x (v:ref<V3d>) -> ref<Double> :
  return new Double{v.x}

public lostanza defn y (v:ref<V3d>) -> ref<Double> :
  return new Double{v.y}

public lostanza defn z (v:ref<V3d>) -> ref<Double> :
  return new Double{v.z}

public defn V3d (v:V3f) -> V3d : V3d(to-double(x(v)), to-double(y(v)), to-double(z(v)))

defmethod equal? (v1:V3d, v2:V3d) :
  x(v1) == x(v2) and y(v1) == y(v2) and z(v1) == z(v2) 

defmethod hash (v:V3d) :
  (7 * ((7 * hash(x(v))) + hash(y(v)))) + hash(z(v))

;;; BOX

public defstruct Boxi <: Geom & Equalable :
  lo: V3i
  hi: V3i

public defn empty-box () :
  Box(V3f(FLOAT-POSITIVE-INFINITY, FLOAT-POSITIVE-INFINITY, FLOAT-POSITIVE-INFINITY),
      V3f(FLOAT-NEGATIVE-INFINITY, FLOAT-NEGATIVE-INFINITY, FLOAT-NEGATIVE-INFINITY))
  
public defn Boxi (v:V3i) -> Boxi :
  Boxi(v, v)

defmethod print (o:OutputStream, b:Boxi) :
  print-all(o, ["Boxi(", lo(b), ",", hi(b) ")"])

public defn union (b0:Boxi, b1:Boxi) -> Boxi :
  Boxi(min(lo(b0), lo(b1)), max(hi(b0), hi(b1)))

public defn center (b:Boxi) -> V3i :
  to-v3i(round(0.5f * to-v3f(lo(b) + hi(b))))

public defn dims (b:Boxi) -> V3i :
  (hi(b) - lo(b)) + V3i(1, 1, 1)

defmethod equal? (b1:Boxi, b2:Boxi) :
  lo(b1) == lo(b2) or hi(b1) == hi(b2)

public defstruct Box <: Geom & Equalable :
  lo: V3f
  hi: V3f

public defn Box (v:V3f) -> Box :
  Box(v, v)

defmethod print (o:OutputStream, b:Box) :
  print-all(o, ["Box(", lo(b), ",", hi(b) ")"])

public defn empty? (b:Box) -> True|False :
  val d = dims(b)
  x(d) < 0.0f or y(d) < 0.0f or z(d) < 0.0f

public defn contains? (b:Box, p:V3f) -> True|False :
  not empty?(b & Box(p))

public defn center (b:Box) -> V3f :
  0.5f * (lo(b) + hi(b))

public defn dims (b:Box) -> V3f :
  hi(b) - lo(b)

public defn corners (b:Box) -> Tuple<V3f> :
  val [l, h] = [lo(b), hi(b)]
  [V3f(x(l), y(l), z(l)),
   V3f(x(l), y(l), z(h)), 
   V3f(x(l), y(h), z(l)), 
   V3f(x(l), y(h), z(h)), 
   V3f(x(h), y(l), z(l)), 
   V3f(x(h), y(l), z(h)),
   V3f(x(h), y(h), z(l)), 
   V3f(x(h), y(h), z(h))]

public defn dims-to-box (dims:V3f) -> Box :
  val hdims = 0.5f * dims
  Box((- hdims), hdims)

public defn union (b:Box, v:V3f) -> Box :
  Box(min(lo(b), v), max(hi(b), v))

public defn union (b0:Box, b1:Box) -> Box :
  Box(min(lo(b0), lo(b1)), max(hi(b0), hi(b1)))

public defn bit-or (b0:Box, b1:Box) -> Box :
  union(b0, b1)

public defn bit-and (b0:Box, b1:Box) -> Box :
  Box(max(lo(b0), lo(b1)), min(hi(b0), hi(b1)))

public defn inf-box () -> Box:
  val [min-inf, max-inf] = [FLOAT-MIN, FLOAT-MAX]
  Box(V3f(min-inf, min-inf, min-inf), V3f(max-inf, max-inf, max-inf))

public defn min-box () -> Box:
  val [min-inf, max-inf] = [FLOAT-MIN, FLOAT-MAX]
  Box(V3f(max-inf, max-inf, max-inf), V3f(min-inf, min-inf, min-inf))

public defn fatten (b:Box, dims:V3f) -> Box :
  Box(lo(b) - dims, hi(b) + dims)

public defn fatten (b:Box, dims:Float) -> Box :
  fatten(b, V3f(dims, dims, dims))

public defn times (mat:Mat44, b:Box) -> Box :
  reduce(union, map(Box{ mat * _ }, corners(b)))

defmethod equal? (b1:Box, b2:Box) :
  lo(b1) == lo(b2) or hi(b1) == hi(b2)

;;; MAT

public lostanza deftype Mat44 <: Array<Float> & Geom :
  m00: float
  m01: float
  m02: float
  m03: float
  m10: float
  m11: float
  m12: float
  m13: float
  m20: float
  m21: float
  m22: float
  m23: float
  m30: float
  m31: float
  m32: float
  m33: float

public lostanza defn Mat44 (m00:ref<Float>,m01:ref<Float>,m02:ref<Float>,m03:ref<Float>,
                            m10:ref<Float>,m11:ref<Float>,m12:ref<Float>,m13:ref<Float>,
                            m20:ref<Float>,m21:ref<Float>,m22:ref<Float>,m23:ref<Float>,
                            m30:ref<Float>,m31:ref<Float>,m32:ref<Float>,m33:ref<Float>) -> ref<Mat44> :
  return new Mat44{m00.value,m01.value,m02.value,m03.value,m10.value,m11.value,m12.value,m13.value,
                   m20.value,m21.value,m22.value,m23.value,m30.value,m31.value,m32.value,m33.value}

lostanza defn mat44-get (m:ref<Mat44>, i:ref<Int>) -> ref<Float> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, new Int{16})
  return new Float{addr!(m.m00)[i.value]}

lostanza defn mat44-set (m:ref<Mat44>, i:ref<Int>, x:ref<Float>) -> ref<False> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, new Int{16})
  addr!(m.m00)[i.value] = x.value
  return false

defmethod get (a:Mat44, i:Int) -> Float : mat44-get(a, i)
defmethod set (a:Mat44, i:Int, c:Float) -> False : mat44-set(a, i, c)
defmethod length (a:Mat44) -> Int : 16

public defn get (m:Mat44, x:Int, y:Int) -> Float :
  m[x * 4 + y]

public defn set (m:Mat44, x:Int, y:Int, v:Float) -> False :
  m[x * 4 + y] = v

defmethod print (o:OutputStream, m:Mat44) :
  print(o, "MAT(")
  for (i in 0 to 16) do :
     if i > 0 : print(o, ",")
     print(o, m[i])
  print-all(o, ")")

public defn reflect-xy-mat44 () -> Mat44 :
  Mat44( 0.0f,  1.0f,  0.0f,  0.0f,
         1.0f,  0.0f,  0.0f,  0.0f,
         0.0f,  0.0f,  1.0f,  0.0f,
         0.0f,  0.0f,  0.0f,  1.0f)
 
public defn reflect-xz-mat44 () -> Mat44 :
  Mat44( 0.0f,  0.0f,  1.0f,  0.0f,
         0.0f,  1.0f,  0.0f,  0.0f,
         1.0f,  0.0f,  0.0f,  0.0f,
         0.0f,  0.0f,  0.0f,  1.0f)
 
public defn reflect-yz-mat44 () -> Mat44 :
  Mat44( 1.0f,  0.0f,  0.0f,  0.0f,
         0.0f,  0.0f,  1.0f,  0.0f,
         0.0f,  1.0f,  0.0f,  0.0f,
         0.0f,  0.0f,  0.0f,  1.0f)
 
public defn shear-x-y-mat44 (ymin:Float, ymax:Float, dx0:Float, dx1:Float) -> Mat44 :
  ;; TODO
  id-mat44()
 
public defn id-mat44 () -> Mat44 : mag-mat44(1.0f)

public defn mag-mat44 (s:Float) -> Mat44 :
  Mat44(   s, 0.0f, 0.0f, 0.0f,
        0.0f,    s, 0.0f, 0.0f,
        0.0f, 0.0f,    s, 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f)
 
public defn mag-mat44 (s:V3f) -> Mat44 :
  Mat44(x(s), 0.0f, 0.0f, 0.0f,
        0.0f, y(s), 0.0f, 0.0f,
        0.0f, 0.0f, z(s), 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f)

public defn mov-mat44 (t:V3f) -> Mat44 :
  Mat44( 1.0f, 0.0f, 0.0f, 0.0f,
         0.0f, 1.0f, 0.0f, 0.0f,
         0.0f, 0.0f, 1.0f, 0.0f,
         t[0], t[1], t[2], 1.0f)

public defn rot-mat44 (r:V3f) -> Mat44 :
  val cos_rz = cos(r[2])
  val cos_ry = cos(r[1])
  val cos_rx = cos(r[0])

  val sin_rz = sin(r[2])
  val sin_ry = sin(r[1])
  val sin_rx = sin(r[0])

  val m00 = cos_rz * cos_ry
  val m01 = sin_rz * cos_ry
  val m02 = (- sin_ry)
  val m10 = (- sin_rz) * cos_rx + cos_rz * sin_ry * sin_rx
  val m11 = cos_rz * cos_rx + sin_rz * sin_ry * sin_rx
  val m12 = cos_ry * sin_rx
  val m20 = (- sin_rz) * (- sin_rx) + cos_rz * sin_ry * cos_rx
  val m21 = cos_rz * (- sin_rx) + sin_rz * sin_ry * cos_rx
  val m22 = cos_ry * cos_rx

  Mat44( m00,  m01,  m02, 0.0f,
         m10,  m11,  m12, 0.0f,
         m20,  m21,  m22, 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f)

public defn rot-mat44 (r:V3f, a:Float) -> Mat44 :
  val u = normalize(r)
  val s = sin(a)
  val c = cos(a)

  val m00 = u[0] * u[0] * (1.0f - c) + c
  val m01 = u[1] * u[0] * (1.0f - c) + u[2] * s
  val m02 = u[2] * u[0] * (1.0f - c) - u[1] * s

  val m10 = u[0] * u[1] * (1.0f - c) - u[2] * s
  val m11 = u[1] * u[1] * (1.0f - c) + c
  val m12 = u[2] * u[1] * (1.0f - c) + u[0] * s

  val m20 = u[0] * u[2] * (1.0f - c) - u[1] * s
  val m21 = u[1] * u[2] * (1.0f - c) + u[0] * s
  val m22 = u[2] * u[2] * (1.0f - c) + c

  Mat44( m00,  m01,  m02, 0.0f,
         m10,  m11,  m12, 0.0f,
         m20,  m21,  m22, 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f)

public defn rot2-mat44 (src:V3f, dst:V3f) -> Mat44 :
  val a = atan2(y(dst), x(dst)) - atan2(y(src), x(src))
  val [c, s] = [cos(a), sin(a)]
  Mat44(    c    s 0.0f 0.0f
        (- s)    c 0.0f 0.0f
         0.0f 0.0f 1.0f 0.0f
         0.0f 0.0f 0.0f 1.0f)

public defn times (m:Mat44, v:V3f) -> V3f :
  val px = x(v) * m[0,0] + y(v) * m[1,0] + z(v) * m[2,0] + m[3,0]
  val py = x(v) * m[0,1] + y(v) * m[1,1] + z(v) * m[2,1] + m[3,1]
  val pz = x(v) * m[0,2] + y(v) * m[1,2] + z(v) * m[2,2] + m[3,2]
  val pw = x(v) * m[0,3] + y(v) * m[1,3] + z(v) * m[2,3] + m[3,3]
  V3f(px / pw, py / pw, pz / pw)

public defn times (a:Mat44, b:Mat44) -> Mat44 :
  val res = id-mat44()
  for i in 0 to 4 do :
    for j in 0 to 4 do :
      var sum: Float = 0.0f
      for k in 0 to 4 do :
        sum = sum + a[i,k] * b[k,j]
      res[i, j] = sum
  res

;;; HALF -- PLANE

public defstruct Half :
  normal:   V3f
  distance: Float

public defmethod print (o:OutputStream, g:Half) :
  print-all(o, ["half(" normal(g) "," distance(g) ")"])

public defn half (x:Float, y:Float, z:Float, d:Float) -> Half :
  Half(V3f(x, y, z), d)

public defn half (v:V3f, d:Float) -> Half :
  Half(v, d)

public defn half (p1:V3f, p2:V3f, p3:V3f) -> Half :
  val normal = normalize((p2 - p1) % (p3 - p1))
  val distance = dot(normal, p1)
  Half(normal, distance)

;; defn times (g:Half, m:Mat44) -> Half :
;;   var dir1:V3f       = V3f(1.0f, 0.0f, 0.0f) % normal(g)
;;   var dir1-len:Float = dot(dir1, dir1)
;;   var tmp:V3f        = V3f(0.0f, 1.0f, 0.0f) % normal(g)
;;   var tmp-len:Float  = dot(tmp, tmp)
;;   if tmp-len > dir1-len :
;;     dir1     = tmp
;;     dir1-len = tmp-len
;;   tmp     = V3f(0.0f,0.0f, 1.0f) % normal(g)
;;   tmp-len = dot(tmp, tmp)
;;   if tmp-len > dir1-len :
;;     dir1     = tmp
;;   val dir2  = dir1 % normal(g)
;;   val point = distance(g) * normal(g)
;;   half(point * m, (point + dir2) * m, (point + dir1) * m)

public defn distance-to (plane:Half, point:V3f) -> Float :
  dot(point, normal(plane)) - distance(plane)

public defn level (g:Half, point:V3f) -> Float :
  (- distance-to(g, point))

;;; LINE

public defstruct Line <: Geom :
  pos: V3f
  dir: V3f

public defn closest-point-to (l:Line, point:V3f) -> V3f :
  dot((point - pos(l)), dir(l)) * dir(l) + pos(l)

public defn line-of (p0:V3f, p1:V3f) -> Line :
  Line(p0, normalize(p1 - p0))

;; public defn extrude (p0:V3f, p1:V3f) -> Half :
;;   val line   = line-of(p0, p1)
;;   val normal = V3f(y(dir(line)), (- x(dir(line))))
;;   val pt     = closest-point-to(line, V3f(0.0f, 0.0f))
;;   val align  = dot(normal, normalize(pt))
;;   ;; println-all(["CLOSEST POINT TO " x(pt) "," y(pt) " NORMAL " x(normal) "," y(normal) " ALIGN " align])
;;   Half(normal, (if align > 0.0f : 1.0f else : -1.0f) * len(pt))

;;; CONTOUR

public defstruct Contour <: Geom :
  points: Tuple<V3f>

defmethod print (o:OutputStream, c:Contour) :
  print("Contour(%,)" % [points(c)])

defn do-print-svg (s:OutputStream, contour:Contour) :
  print(s, "<path d=\"")
  for (p in points(contour), i in 0 to false) do :  
    print-all(s, [" " ("M" when i == 0 else "L") " " x(p) " " y(p)])
  print(s, " Z \" fill=\"none\" stroke=\"red\" stroke-width=\"0.02\"/>")

public defn circle-n (d:Float, n:Int) -> Polygon :
  val r = 0.5f * d
  val points = 
    for i in 0 to n seq :
      val a = to-float(i) * 2.0f * PI-F / to-float(n)
      V2f(r * sin(a), r * cos(a))
  to-polygon(Contour(to-tuple(points)))

public defn to-polygon (c:Contour) -> Polygon :
  Polygon([c])

public defn times (mat:Mat44, p:Contour) -> Contour :
  Contour(for p in points(p) map : mat * p)

public defn plus (p:Contour, off:V3f) -> Contour :
  Contour(for p in points(p) map : p + off)

public defn minus (p:Contour, off:V3f) -> Contour :
  Contour(for p in points(p) map : p - off)

public defn segments (contour:Contour) -> Seq<[V3f, V3f]> :
  val pts = points(contour)
  for i in 0 to length(pts) seq :
    [pts[i], pts[(i + 1) % length(pts)]]

;; ;;; STROKE
;; 
;; public defstruct Stroke <: Geom :
;;   points: Tuple<V3f>
;; 
;; defmethod print (o:OutputStream, c:Stroke) :
;;   print("Stroke(%,)" % [points(c)])
;; 
;; public defn times (mat:Mat44, p:Stroke) -> Stroke :
;;   Stroke(for p in points(p) map : mat * p)

;;; POLYGON

public defstruct Polygon <: Geom :
  contours: Tuple<Contour>

public defn points (p:Polygon) -> Tuple<V3f> :
  to-tuple $ cat-all(for c in contours(p) seq : points(c))

defmethod print (o:OutputStream, c:Polygon) :
  print("Polygon(%,)" % [contours(c)])

public defn times (mat:Mat44, p:Polygon) -> Polygon :
  Polygon(for c in contours(p) map : mat * c)

public defn plus (p:Polygon, off:V3f) -> Polygon :
  Polygon(for c in contours(p) map : c + off)

public defn minus (p:Polygon, off:V3f) -> Polygon :
  Polygon(for c in contours(p) map : c - off)

public defn segments (polygon:Polygon) -> Seq<[V3f, V3f]> :
  cat-all(for c in contours(polygon) seq : segments(c))

defn do-print-svg (s:OutputStream, polygon:Polygon, bounds:Box) :
  println-all(s, ["<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>"])
  println-all(s, ["<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\""])
  println-all(s, [" width=\"" x(dims(bounds)) "\" height=\"" y(dims(bounds)) "\" id=\"cons\">"])
  val poly = polygon - lo(bounds)
  for c in contours(poly) do :
    do-print-svg(s, c)
  println(s, "\n</svg>")

public defn svg (polygon:Polygon, filename:String, bounds:Box) :
  val s = FileOutputStream(filename)
  try : do-print-svg(s, polygon, bounds)
  finally : close(s)

;;; POLYLINE

public defstruct PolyLine <: Geom :
  ;; strokes: Tuple<Stroke>
  strokes: Tuple<Tuple<V3f>>

defmethod print (o:OutputStream, c:PolyLine) :
  print("PolyLine(%,)" % [strokes(c)])

public defn bbox (p:PolyLine) -> Box :
  if length(strokes(p)) == 0 :
    Box(V2f(0.0f, 0.0f), V2f(0.0f, 0.0f))
  else :
    val boxes = seq(reduce{union, empty-box(), seq(Box, _)}, strokes(p))
    reduce(union, empty-box(), boxes)

public defn times (mat:Mat44, p:PolyLine) -> PolyLine :
  PolyLine(for s in strokes(p) map : for v in s map : mat * v)

public defn center (p:PolyLine) -> PolyLine :
  mov-mat44((- center(bbox(p)))) * p
  
public defn center-x (p:PolyLine) -> PolyLine :
  mov-mat44(V3f((- x(center(bbox(p)))), 0.0f, 0.0f)) * p

public defn mag (p:PolyLine, fac:V3f) -> PolyLine :
  mag-mat44(fac) * p

public defn offset (p:PolyLine, off:V3f) -> PolyLine :
  mov-mat44(off) * p

public defn segments (polyline:PolyLine) -> Seq<[V3f, V3f]> :
  generate<[V3f, V3f]> :
    for s in strokes(polyline) do :
      for i in 0 to (length(s) - 1) do :
        yield([s[i], s[i + 1]])

;;; MESH
 
public defstruct Mesh <: Geom :
  vertices: Tuple<V3f>
  faces:    Tuple<V3i>

defmethod print (o:OutputStream, m:Mesh) :
  print-all(o, ["Mesh(" vertices(m) "," faces(m) ")"])

;; ;; public defn triangulate (p: Polygon) :
;; ;;   val vertices = Vector<V3f>()
;; ;;   val faces  = Vector<Int>()
;; ;; 
;; ;;   defn vertex-callback (index: Int) :
;; ;;     ;; println("Vertex Callback")
;; ;;     add(faces, index)
;; ;; 
;; ;;   defn combine-callback (x:Float, y:Float, z:Float) -> Int :
;; ;;     ;; println("Combine Callback")
;; ;;     add(vertices, V3f(x, y, z))
;; ;;     length(vertices) - 1
;; ;; 
;; ;;   val tess-ptr = call-c(triangulator_new, vertex-callback, combine-callback)
;; ;; 
;; ;;   call-c(triangulator_begin_polygon, tess-ptr)
;; ;;   for c in contours(p) do :
;; ;;     call-c(triangulator_begin_contour, tess-ptr)
;; ;;     for p in points(c) do :
;; ;;       add(vertices, p)
;; ;;       call-c(triangulator_vertex, tess-ptr, length(vertices) - 1, x(p), y(p), z(p))
;; ;;     call-c(triangulator_end_contour, tess-ptr)
;; ;;   call-c(triangulator_end_polygon, tess-ptr)
;; ;; 
;; ;;   Mesh(vertices, faces)

;;; QUAT

public defstruct Quat <: Geom & Equalable :
  w: Float
  v: V3f

public defn quat-from-axis (axis:V3f, rads:Float) -> Quat :
  val angle = rads / 2.0f
  val sin-angle = sin(angle)
  val n = normalize(axis)
  Quat(cos(angle), sin-angle * n)

public defn Quat () -> Quat :
  quat-from-axis(V3f(1.0f, 0.0f, 0.0f), 0.0f)

defmethod print (o:OutputStream, q:Quat) :
  print-all(o, ["Quat(" v(q) "," w(q) ")"])

defmethod equal? (q1:Quat, q2:Quat) :
  v(q1) == v(q2) and w(q1) == w(q2) 

public defn times (s:Float, q:Quat) -> Quat :
  Quat(s * w(q), s * v(q))

public defn divide (q:Quat, d:Float) -> Quat :
  Quat(w(q) / d, v(q) / d)

public defn x (q:Quat) -> Float : x(v(q))
public defn y (q:Quat) -> Float : y(v(q))
public defn z (q:Quat) -> Float : z(v(q))

public defn times (q1:Quat, q2:Quat) -> Quat :
  Quat(w(q1) * w(q2) - dot(v(q1), v(q2)), w(q1) * v(q2) + w(q2) * v(q1) + v(q1) % v(q2))

public defn dot (q1:Quat, q2:Quat) -> Float :
  dot(v(q1), v(q2)) + w(q1) * w(q2)

public defn conjugate (q:Quat) -> Quat :
  Quat(w(q), (- v(q)))

public defn negate (q:Quat) -> Quat :
  conjugate(q) / dot(q, q)

public defn magnitude (q:Quat) -> Float :
  sqrt(dot(q, q))

public defn normalize (q:Quat) -> Quat :
  q / magnitude(q)

val DELTA = 0.95f

public defn slerp (src:Quat, dst0:Quat, t:Float) -> Quat :
  val cosom0 = dot(src, dst0)
  val [cosom, dst] =
    if cosom0 < 0.0f :
      [(- cosom0), -1.0f * dst0]
    else :
      [cosom0, dst0]
  val [s0, s1] =
    if (1.0f - cosom) > DELTA :
      val omega = acos(cosom)
      val sinom = sin(omega)
      [sin((1.0f - t) * omega) / sinom, sin(t * omega) / sinom]
    else :
      [1.0f - t, t]
  Quat(s0 * w(src) + s1 * w(dst), s0 * v(src) + s1 * v(dst))

public defn quat-to-mat44 (q:Quat) -> Mat44 :
  val [ wx,  wy,  wz] = [w(q) * x(q), w(q) * y(q), w(q) * z(q)]
  val [ xx,  xy,  xz] = [x(q) * x(q), x(q) * y(q), x(q) * z(q)]
  val [ yy,  yz,  zz] = [y(q) * y(q), y(q) * z(q), z(q) * z(q)]
  val [m00, m01, m02] = [1.0f - 2.0f * (yy + zz),        2.0f * (xy - wz),        2.0f * (xz + wy)]
  val [m10, m11, m12] = [       2.0f * (xy + wz), 1.0f - 2.0f * (xx + zz),        2.0f * (yz - wx)]
  val [m20, m21, m22] = [       2.0f * (xz - wy),        2.0f * (yz + wx), 1.0f - 2.0f * (xx + yy)]
  Mat44( m00,  m01,  m02, 0.0f,
         m10,  m11,  m12, 0.0f,
         m20,  m21,  m22, 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f)

;;; ARCBALL

val epsilon = 0.000001f

public defstruct ArcBall :
  st-vec: V3f with: (setter => st-vec-set)
  en-vec: V3f with: (setter => en-vec-set)
  adjust-width: Float with: (setter => adjust-width-set)
  adjust-height: Float with: (setter => adjust-height-set)
  quat : Quat with: (setter => set-quat)
  base-quat : Quat with: (setter => set-base-quat)
  rot : Mat44 with: (setter => set-rot)

public defn clone (ball:ArcBall) :
  ArcBall(adjust-width(ball), adjust-height(ball))
  
public defn set-bounds (a:ArcBall, new-width:Float, new-height:Float) :
  ;; adjust-width-set(a, 1.0f / ((new-width - 1.0f) * 0.5f))
  ;; adjust-height-set(a, 1.0f / ((new-width - 1.0f) * 0.5f))
  adjust-width-set(a, new-width)
  adjust-height-set(a, new-height)

defn clip (x:Float, mn:Float, mx:Float) -> Float :
  min(mx, max(mn, x))

public defn map-to-sphere (a:ArcBall, new-pt:V3f) -> V3f :
  ;; val pt = V2f(x(new-pt) * adjust-width(a) - 1.0f, 1.0f - (y(new-pt) * adjust-height(a)))
  val pt = V2f(clip(   2.0f * x(new-pt) / adjust-width(a)  - 1.0f,   -1.0f, 1.0f),
               clip((-(2.0f * y(new-pt) / adjust-height(a) - 1.0f)), -1.0f, 1.0f))
  ;; println-all(["NEW-PT " new-pt " AW " adjust-width(a) " AH " adjust-height(a) " PT = " pt])
  val len2 = dot(pt, pt)
  val res = 
    if len2 > 1.0f :
      ;; (1.0f / sqrt(len2)) * pt
      ;; println("> 1.0f")
      val len  = sqrt(len2)
      val res  = V3f(x(pt), y(pt), 1.0f / len)
      val rlen = sqrt(len2 + z(res) * z(res))
      normalize(res / rlen)
    else :
      V3f(x(pt), y(pt), sqrt(1.0f - len2))
  ;; println-all(["RES = " res])
  res

public defn ArcBall (new-width:Float, new-height:Float) -> ArcBall :
  val res = ArcBall(V3f(0.0f, 0.0f, 0.0f), V3f(0.0f, 0.0f, 0.0f), 0.0f, 0.0f, Quat(), Quat(), id-mat44())
  set-bounds(res, new-width, new-height)
  res

public defn click (a:ArcBall, new-pt:V3f) :
  ;; println-all(["CLICK " new-pt])
  st-vec-set(a, map-to-sphere(a, new-pt))
  set-quat(a, base-quat(a))

public defn reset! (a:ArcBall) :
  set-rot(a, id-mat44())
  set-quat(a, Quat())
  set-base-quat(a, Quat())

public defn drag (a:ArcBall, new-pt:V3f) :
  ;; println-all(["DRAG  " new-pt])
  en-vec-set(a, map-to-sphere(a, new-pt))
  val perp = st-vec(a) % en-vec(a)
  if magnitude(perp) > epsilon :
    val q = normalize(Quat(dot(st-vec(a), en-vec(a)), perp))
    ;; set-quat(a, (- q) * base-quat(a))
    ;; set-quat(a, conjugate(q) * base-quat(a))
    ;; set-quat(a, base-quat(a) * conjugate(q))
    set-quat(a, base-quat(a) * q)
    set-rot(a, quat-to-mat44(quat(a)))
    q
    
public defn complete-drag (a:ArcBall) :
 set-base-quat(a, quat(a))

public val MOV-AMOUNT = 2000.0f
public val MAG-SCALE  = 0.008f
public val MOV-SCALE  = 0.0001f

public defstruct Transformation :
  ball : ArcBall with: (setter => set-ball)
  mag : Float with: (setter => set-mag)
  mov : V3f with: (setter => set-mov)
  last-x : Float with: (setter => set-last-x)

public defn clone (xform:Transformation) :
  Transformation(clone(ball(xform)), mag(xform), V2f(0.0f, 0.0f), 0.0f)

public defn mov! (xform:Transformation, amount:V3f) :
  set-mov(xform, mov(xform) + MOV-SCALE * amount)

public defn reset! (t:Transformation) :
  reset!(ball(t))
  set-mov(t, V2f(0.0f, 0.0f))
  set-mag(t, 1.0f)
  set-last-x(t, 0.0f)
