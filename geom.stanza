;; See license.txt for details about licensing.

defpackage geom:
  import core
  import math
  import collections
  import utils

public deftype Geom

public defstruct Msg <: Geom :
  value : String

public defn ensure-index-in-bounds (i:Int, n:Int) :
  #if-defined(OPTIMIZE) :
    false
  #else :
    if i < 0 or i >= n :
      fatal("Index (%_) out of bounds." % [i])

public val pos-inf-f =  1.0e6f
public val neg-inf-f = -1.0e6f
public val pos-inf-d =  1.0e6
public val neg-inf-d = -1.0e6
public val pos-inf-i =  (1 << 30)
public val neg-inf-i = (-(1 << 30))

;;; PIXELS

public defstruct Pixels <: Geom :
  idims: V3i
  dim: Float
  data: ByteArray

public defn index (g:Pixels, i:Int, j:Int, k:Int) -> Int :
  (k * idims(g)[0] * idims(g)[1]) + j * idims(g)[0] + i

public defn index (g:Pixels, pos:V3i) -> Int :
  index(g, x(pos), y(pos), z(pos))

public defn get (g:Pixels, i:Int, j:Int, k:Int) -> Byte :
  data(g)[index(g, i, j, k)]

public defn get (g:Pixels, pos:V3i) -> Byte :
  data(g)[index(g, pos)]

public defn set (g:Pixels, pos:V3i, v:Byte) -> False :
  data(g)[index(g, pos)] = v

public defn indices (dims:V3i) -> Seq<V3i> :
  generate<V3i> :
    for k in 0 to z(dims) do :
      for j in 0 to y(dims) do :
        for i in 0 to x(dims) do :
          yield(V3i(i, j, k))

public defn indices (bounds:Box3i) -> Seq<V3i> :
  generate<V3i> :
    for k in z(lo(bounds)) through z(hi(bounds)) do :
      for j in y(lo(bounds)) through y(hi(bounds)) do :
        for i in x(lo(bounds)) through x(hi(bounds)) do :
          yield(V3i(i, j, k))

;;; VECS

public lostanza deftype Vf <: Array<Float> & Geom :
  length: long
  elts:   float ...

public lostanza defn Vf (n:ref<Int>, x:ref<Float>) -> ref<Vf> :
  ensure-non-negative-length(n)
  val l = n.value
  val a = new Vf{l}
  val c = x.value
  for (var i:long = 0, i < l, i = i + 1) :
    a.elts[i] = c
  return a

;; USE PRIMARRAYS

public defn Vf (n:Int) -> Vf :
  Vf(n, 0.0f)

lostanza defn vf-get (v:ref<Vf>, i:ref<Int>) -> ref<Float> :
  ensure-index-in-bounds(i, length(v))
  return new Float{v.elts[i.value]}
  
lostanza defn vf-set (v:ref<Vf>, i:ref<Int>, x:ref<Float>) -> ref<False> :
  ensure-index-in-bounds(i, length(v))
  v.elts[i.value] = x.value
  return false
  
lostanza defn vf-length (v:ref<Vf>) -> ref<Int> :
  return new Int{v.length as int}
  
defmethod get (a:Vf, i:Int) -> Float : vf-get(a, i)
defmethod set (a:Vf, i:Int, c:Float) -> False : vf-set(a, i, c)
defmethod length (a:Vf) -> Int : vf-length(a)

defmethod print (o:OutputStream, v:Vf) :
  print-all(o, ["Vf(" length(v) ")"])

public lostanza deftype Vi <: Array<Int> & Geom :
  length: long
  elts:   int ...

public lostanza defn Vi (n:ref<Int>, x:ref<Int>) -> ref<Vi> :
  ensure-non-negative-length(n)
  val l = n.value
  val a = new Vi{l}
  val c = x.value
  for (var i:long = 0, i < l, i = i + 1) :
    a.elts[i] = c
  return a

public defn Vi (n:Int) -> Vi :
  Vi(n, 0)

lostanza defn vi-get (v:ref<Vi>, i:ref<Int>) -> ref<Int> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, length(v))
  return new Int{v.elts[i.value]}
  
lostanza defn vi-set (v:ref<Vi>, i:ref<Int>, x:ref<Int>) -> ref<False> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, length(v))
  v.elts[i.value] = x.value
  return false
  
lostanza defn vi-length (v:ref<Vi>) -> ref<Int> :
  return new Int{v.length as int}
  
defmethod get (a:Vi, i:Int) -> Int : vi-get(a, i)
defmethod set (a:Vi, i:Int, c:Int) -> False : vi-set(a, i, c)
defmethod length (a:Vi) -> Int : vi-length(a)

defmethod print (o:OutputStream, v:Vi) :
  print-all(o, ["Vi(" length(v) ")"])

public lostanza deftype Vb <: Array<Byte> & Geom :
  length: long
  elts:   byte ...

public lostanza defn Vb (n:ref<Int>, x:ref<Byte>) -> ref<Vb> :
  ensure-non-negative-length(n)
  val l = n.value
  val a = new Vb{l}
  val c = x.value
  for (var i:long = 0, i < l, i = i + 1) :
    a.elts[i] = c
  return a

public defn Vb (n:Int) -> Vb :
  Vb(n, to-byte $ 0)

lostanza defn vi-get (v:ref<Vb>, i:ref<Int>) -> ref<Byte> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, length(v))
  return new Byte{v.elts[i.value]}
  
lostanza defn vi-set (v:ref<Vb>, i:ref<Int>, x:ref<Byte>) -> ref<False> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, length(v))
  v.elts[i.value] = x.value
  return false
  
lostanza defn vi-length (v:ref<Vb>) -> ref<Int> :
  return new Int{v.length as int}
  
defmethod get (a:Vb, i:Int) -> Byte : vi-get(a, i)
defmethod set (a:Vb, i:Int, c:Byte) -> False : vi-set(a, i, c)
defmethod length (a:Vb) -> Int : vi-length(a)

defmethod print (o:OutputStream, v:Vb) :
  print-all(o, ["Vb(" length(v) ")"])

;;; V3x

defn round (x:Int) : x
defn sqrt (x:Int) : to-int(round(sqrt(to-float(x))))

#for (Prim in [Int Float Double]
      prim in [int float double]
      PrimVec in [V3i V3f V3d]
      PrimVecName in ["V3i" "V3f" "V3d"]
      PrimVec2 in [V2i V2f V2d]
      prim-fill in [V3i-fill V3f-fill V3d-fill]
      prim-unit in [V3i-unit V3f-unit V3d-unit]
      x0 in [0 0.0f 0.0]
      x1 in [1 1.0f 1.0]) :

  public lostanza deftype PrimVec <: Array<Prim> & Hashable & Geom :
    x: prim
    y: prim
    z: prim

  public lostanza defn PrimVec (x:ref<Prim>, y:ref<Prim>, z:ref<Prim>) -> ref<PrimVec> :
    return new PrimVec{x.value, y.value, z.value}

  public lostanza defn x (v:ref<PrimVec>) -> ref<Prim> :
    return new Prim{v.x}

  public lostanza defn y (v:ref<PrimVec>) -> ref<Prim> :
    return new Prim{v.y}

  public lostanza defn z (v:ref<PrimVec>) -> ref<Prim> :
    return new Prim{v.z}

  public defn PrimVec (x:Prim, y:Prim) -> PrimVec :
    PrimVec(x, y, x0)

  public defn prim-fill (a:Prim) : PrimVec(a, a, a)

  public defn prim-unit (i:Int) :
    if i == 0 :      PrimVec(x1, x0, x0)
    else if i == 1 : PrimVec(x0, x1, x0)
    else :           PrimVec(x0, x0, x1)

  public defn set-elt (v:PrimVec, i:Int, a:Prim) -> PrimVec :
    PrimVec(a when i == 0 else v[0], a when i == 1 else v[1], a when i == 2 else v[2])

  lostanza defmethod get (v:ref<PrimVec>, i:ref<Int>) -> ref<Prim> : 
    ensure-index-in-bounds(i, new Int{3})
    return new Prim{addr!(v.x)[i.value]}

  defmethod length (a:PrimVec) -> Int : 3

  public defn area (a:PrimVec) -> Prim :
    x(a) * y(a)

  public defn volume (a:PrimVec) -> Prim :
    x(a) * y(a) * z(a)

  defmethod equal? (v1:PrimVec, v2:PrimVec) :
    x(v1) == x(v2) and y(v1) == y(v2) and z(v1) == z(v2) 

  defmethod hash (v:PrimVec) :
    (7 * ((7 * hash(x(v))) + hash(y(v)))) + hash(z(v))

  public defn xy (p:PrimVec) -> PrimVec2 :
    PrimVec2(x(p), y(p))

  public defn xyz (p:PrimVec) -> PrimVec : p

  defmethod print (o:OutputStream, v:PrimVec) :
    print-all(o, [PrimVecName "(", x(v), ",", y(v), ",", z(v), ")"])

  public defn magnitude (a:PrimVec) -> Prim :
    sqrt(dot(a, a))

  public defn distance (v0:PrimVec, v1:PrimVec) -> Prim :
    magnitude(v1 - v0)

  public defn normalize (a:PrimVec) -> PrimVec :
    a / magnitude(a)

  public defn dot (a:PrimVec, b:PrimVec) -> Prim :
    x(a) * x(b) + y(a) * y(b) + z(a) * z(b)

  public defn min (a:PrimVec) -> Prim :
    min(x(a), min(y(a), z(a)))

  public defn max (a:PrimVec) -> Prim :
    max(x(a), max(y(a), z(a)))

  public defn min (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(min(x(a), x(b)), min(y(a), y(b)), min(z(a), z(b)))

  public defn max (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(max(x(a), x(b)), max(y(a), y(b)), max(z(a), z(b)))

  public defn times (a:Prim, b:PrimVec) -> PrimVec :
    PrimVec(a * x(b), a * y(b), a * z(b))

  public defn times (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(x(a) * x(b), y(a) * y(b), z(a) * z(b))

  public defn divide (a:PrimVec, b:Prim) -> PrimVec :
    PrimVec(x(a) / b, y(a) / b, z(a) / b)

  public defn divide (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(x(a) / x(b), y(a) / y(b), z(a) / z(b))

  public defn modulo (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(y(a) * z(b) - z(a) * y(b),
            z(a) * x(b) - x(a) * z(b),
            x(a) * y(b) - y(a) * x(b))

  public defn plus (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(x(a) + x(b), y(a) + y(b), z(a) + z(b))

  public defn minus (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(x(a) - x(b), y(a) - y(b), z(a) - z(b))

  public defn negate (a:PrimVec) -> PrimVec :
    PrimVec((- x(a)), (- y(a)), (- z(a)))

  public defn round (p:PrimVec) -> PrimVec :
    PrimVec(round(x(p)), round(y(p)), round(z(p)))

  public defn sorted-indices (v:PrimVec) -> V3i :
    if x(v) < y(v) :
      if x(v) < z(v) :
        V3i(0, 1, 2) when y(v) < z(v) else V3i(0, 2, 1)
      else :
        V3i(2, 0, 1)
    else :
      if y(v) < z(v) :
        V3i(1, 0, 2) when x(v) < z(v) else V3i(1, 2, 0)
      else :
        V3i(2, 1, 0)

  public defn min-idx (v:PrimVec) -> Int :
    sorted-indices(v)[0]

  public defn mid-idx (v:PrimVec) -> Int :
    sorted-indices(v)[1]

  public defn max-idx (v:PrimVec) -> Int :
    sorted-indices(v)[2]

;;; V2x

#for (Prim in [Int Float Double]
      prim in [int float double]
      PrimVec in [V2i V2f V2d]
      PrimVecName in ["V2i" "V2f" "V2d"]
      PrimVec3 in [V3i V3f V3d]
      prim-fill in [V2i-fill V2f-fill V2d-fill]
      prim-unit in [V2i-unit V2f-unit V2d-unit]
      x0 in [0 0.0f 0.0]
      x1 in [1 1.0f 1.0]) :

  public lostanza deftype PrimVec <: Array<Prim> & Hashable & Geom :
    x: prim
    y: prim

  public lostanza defn PrimVec (x:ref<Prim>, y:ref<Prim>) -> ref<PrimVec> :
    return new PrimVec{x.value, y.value}

  public lostanza defn x (v:ref<PrimVec>) -> ref<Prim> :
    return new Prim{v.x}

  public lostanza defn y (v:ref<PrimVec>) -> ref<Prim> :
    return new Prim{v.y}

  public defn prim-fill (a:Prim) : PrimVec(a, a)

  public defn prim-unit (i:Int) :
    if i == 0 : PrimVec(x1, x0)
    else :      PrimVec(x0, x1)

  public defn set-elt (v:PrimVec, i:Int, a:Prim) -> PrimVec :
    PrimVec(a when i == 0 else v[0], a when i == 1 else v[1])

  lostanza defmethod get (v:ref<PrimVec>, i:ref<Int>) -> ref<Prim> : 
    ensure-index-in-bounds(i, new Int{2})
    return new Prim{addr!(v.x)[i.value]}

  defmethod length (a:PrimVec) -> Int : 2

  public defn area (a:PrimVec) -> Prim :
    x(a) * y(a)

  public defn volume (a:PrimVec) -> Prim :
    x0

  defmethod equal? (v1:PrimVec, v2:PrimVec) :
    x(v1) == x(v2) and y(v1) == y(v2)

  defmethod hash (v:PrimVec) :
    ((7 * hash(x(v))) + hash(y(v)))

  public defn xy (p:PrimVec) -> PrimVec : p

  public defn xyz (p:PrimVec) -> PrimVec3 :
    PrimVec3(x(p), y(p), x0)

  defmethod print (o:OutputStream, v:PrimVec) :
    print-all(o, [PrimVecName "(", x(v), ",", y(v), ")"])

  public defn magnitude (a:PrimVec) -> Prim :
    sqrt(dot(a, a))

  public defn distance (v0:PrimVec, v1:PrimVec) -> Prim :
    magnitude(v1 - v0)

  public defn normalize (a:PrimVec) -> PrimVec :
    a / magnitude(a)

  public defn dot (a:PrimVec, b:PrimVec) -> Prim :
    x(a) * x(b) + y(a) * y(b)

  public defn min (a:PrimVec) -> Prim :
    min(x(a), y(a))

  public defn max (a:PrimVec) -> Prim :
    max(x(a), y(a))

  public defn min (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(min(x(a), x(b)), min(y(a), y(b)))

  public defn max (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(max(x(a), x(b)), max(y(a), y(b)))

  public defn times (a:Prim, b:PrimVec) -> PrimVec :
    PrimVec(a * x(b), a * y(b))

  public defn times (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(x(a) * x(b), y(a) * y(b))

  public defn divide (a:PrimVec, b:Prim) -> PrimVec :
    PrimVec(x(a) / b, y(a) / b)

  public defn divide (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(x(a) / x(b), y(a) / y(b))

  public defn plus (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(x(a) + x(b), y(a) + y(b))

  public defn minus (a:PrimVec, b:PrimVec) -> PrimVec :
    PrimVec(x(a) - x(b), y(a) - y(b))

  public defn negate (a:PrimVec) -> PrimVec :
    PrimVec((- x(a)), (- y(a)))

  public defn round (p:PrimVec) -> PrimVec :
    PrimVec(round(x(p)), round(y(p)))

  public defn sorted-indices (v:PrimVec) -> V2i :
    V2i(0, 1) when x(v) < y(v) else V2i(1, 0)

  public defn min-idx (v:PrimVec) -> Int :
    0 when x(v) < y(v) else 1

  public defn max-idx (v:PrimVec) -> Int :
    1 when x(v) < y(v) else 0

public defn to-v3d (v:V3f) -> V3d :
  V3d(to-double(x(v)), to-double(y(v)), to-double(z(v)))

public defn to-v3i (v:V3f) -> V3i :
  V3i(to-int(x(v)), to-int(y(v)), to-int(z(v)))

public defn to-v3f (v:V3i) -> V3f :
  V3f(to-float(x(v)), to-float(y(v)), to-float(z(v)))

public defn to-v2i (v:V2f) -> V2i :
  V2i(to-int(x(v)), to-int(y(v)))

public defn to-v2f (v:V2i) -> V2f :
  V2f(to-float(x(v)), to-float(y(v)))

;;; Interval 

public lostanza deftype Interval <: Geom & Equalable :
  lo: float
  hi: float

public lostanza defn Interval (lo:ref<Float>, hi:ref<Float>) -> ref<Interval> :
  return new Interval{lo.value, hi.value}

public lostanza defn lo (i:ref<Interval>) -> ref<Float> :
  return new Float{i.lo}

public lostanza defn hi (i:ref<Interval>) -> ref<Float> :
  return new Float{i.hi}

defmethod equal? (i1:Interval, i2:Interval) :
  lo(i1) == lo(i2) and hi(i1) == hi(i2)

defmethod print (o:OutputStream, i:Interval) :
  print-all(o, ["Interval(", lo(i), ",", hi(i) ")"])

;;; V4f

;; public defstruct V4f <: Array<Float> :
;;   x: Float
;;   y: Float
;;   z: Float
;;   a: Float

public lostanza deftype V4f <: Array<Float> & Geom & Hashable :
  x: float
  y: float
  z: float
  a: float

public lostanza defn V4f (x:ref<Float>, y:ref<Float>, z:ref<Float>, a:ref<Float>) -> ref<V4f> :
  return new V4f{x.value, y.value, z.value, a.value}

public lostanza defn x (v:ref<V4f>) -> ref<Float> :
  return new Float{v.x}

public lostanza defn y (v:ref<V4f>) -> ref<Float> :
  return new Float{v.y}

public lostanza defn z (v:ref<V4f>) -> ref<Float> :
  return new Float{v.z}

public lostanza defn a (v:ref<V4f>) -> ref<Float> :
  return new Float{v.a}

public defn V4f (x:Float, y:Float, z:Float) -> V4f :
  V4f(x, y, z, 0.0f)

public lostanza defmethod get (v:ref<V4f>, i:ref<Int>) -> ref<Float> :
  ensure-index-in-bounds(i, new Int{3})
  return new Float{addr!(v.x)[i.value]}

public defmethod length (a:V4f) -> Int : 4

defmethod equal? (v1:V4f, v2:V4f) :
  x(v1) == x(v2) and y(v1) == y(v2) and z(v1) == z(v2) and a(v1) == a(v2) 

defmethod hash (v:V4f) :
  (7 * ((7 * ((7 * hash(x(v))) + hash(y(v)))) + hash(z(v)))) + hash(a(v))

defmethod print (o:OutputStream, v:V4f) :
  print-all(o, ["V4f(", x(v) "," y(v) "," z(v) "," a(v) ")"])

public val RED   = V4f(1.0f, 0.0f, 0.0f, 1.0f)
public val GREEN = V4f(0.0f, 1.0f, 0.0f, 1.0f)
public val BLUE  = V4f(0.0f, 0.0f, 1.0f, 1.0f)
public val BLACK  = V4f(0.0f, 0.0f, 0.0f, 1.0f)
public val WHITE  = V4f(1.0f, 1.0f, 1.0f, 1.0f)

;;; BOX2 and BOX3

#for (Prim in [Int Float Double Int Float Double]
      BoxVec in [V3i V3f V3d V2i V2f V2d]
      BoxName in ["Box3i" "Box3f" "Box3d" "Box2i" "Box2f" "Box2d"]
      BoxVec-fill in [V3i-fill V3f-fill V3d-fill V2i-fill V2f-fill V2d-fill]
      Box in [Box3i Box3f Box3d Box2i Box2f Box2d]
      neg-inf in [neg-inf-i, neg-inf-f, neg-inf-d, neg-inf-i, neg-inf-f, neg-inf-d]
      pos-inf in [pos-inf-i, pos-inf-f, pos-inf-d, pos-inf-i, pos-inf-f, pos-inf-d]
      pos-inf-box in [pos-inf-box3i, pos-inf-box3f, pos-inf-box3d, pos-inf-box2i, pos-inf-box2f, pos-inf-box2d]
      neg-inf-box in [neg-inf-box3i, neg-inf-box3f, neg-inf-box3d, neg-inf-box2i, neg-inf-box2f, neg-inf-box2d]
      x2 in [2 2.0f 2.0, 2, 2.0f, 2.0]
      x0 in [0 0.0f 0.0, 0, 0.0f, 0.0]) :

  public defstruct Box <: Geom & Equalable :
    lo: BoxVec
    hi: BoxVec

  public defn Box (v:BoxVec) -> Box :
    Box(v, v)

  defmethod print (o:OutputStream, b:Box) :
    print-all(o, [BoxName "(", lo(b), ",", hi(b) ")"])

  public defn contains? (b:Box, p:BoxVec) -> True|False :
    not empty?(b & Box(p))

  public defn center (b:Box) -> BoxVec :
    (lo(b) + hi(b)) / x2

  public defn dims (b:Box) -> BoxVec :
    hi(b) - lo(b)

  public defn dims-to-box (dims:BoxVec) -> Box :
    val hdims = dims / x2
    Box((- hdims), hdims)

  public defn union (b:Box, v:BoxVec) -> Box :
    Box(min(lo(b), v), max(hi(b), v))

  public defn union (b0:Box, b1:Box) -> Box :
    Box(min(lo(b0), lo(b1)), max(hi(b0), hi(b1)))

  public defn bit-or (b0:Box, b1:Box) -> Box :
    union(b0, b1)

  public defn bit-and (b0:Box, b1:Box) -> Box :
    Box(max(lo(b0), lo(b1)), min(hi(b0), hi(b1)))

  public defn pos-inf-box () -> Box:
    Box(BoxVec-fill(neg-inf), BoxVec-fill(pos-inf))

  public defn neg-inf-box () -> Box:
    Box(BoxVec-fill(pos-inf), BoxVec-fill(neg-inf))

  public defn fatten (b:Box, dims:BoxVec) -> Box :
    Box(lo(b) - dims, hi(b) + dims)

  public defn fatten (b:Box, dims:Prim) -> Box :
    fatten(b, BoxVec-fill(dims))

  public defn plus (b:Box, off:BoxVec) -> Box :
    Box(lo(b) + off, hi(b) + off)

  public defn minus (b:Box, off:BoxVec) -> Box :
    Box(lo(b) - off, hi(b) - off)

  defmethod equal? (b1:Box, b2:Box) :
    lo(b1) == lo(b2) and hi(b1) == hi(b2)

#for (BoxVec in [V2i V2f V2d]
      Box in [Box2i Box2f Box2d]
      Box3 in [Box3i Box3f Box3d]
      x0 in [0 0.0f 0.0]) :

  public defn xy (b:Box) -> Box : b

  public defn xyz (b:Box) -> Box3 :
    Box3(xyz(lo(b)), xyz(hi(b)))

  public defn empty? (b:Box) -> True|False :
    val d = dims(b)
    x(d) < x0 or y(d) < x0

  public defn corners (b:Box) -> Tuple<BoxVec> :
    val [l, h] = [lo(b), hi(b)]
    [BoxVec(x(l), y(l)),
     BoxVec(x(l), y(h)), 
     BoxVec(x(h), y(h)),
     BoxVec(x(h), y(l))] 

  public defn intersects? (b0:Box, b1:Box) -> True|False :
    not ((x(hi(b0)) < x(lo(b1)) or x(lo(b0)) > x(hi(b1))) or
         (y(hi(b0)) < y(lo(b1)) or y(lo(b0)) > y(hi(b1))))

#for (BoxVec in [V3i V3f V3d]
      Box in [Box3i Box3f Box3d]
      Box2 in [Box2i Box2f Box2d]
      x0 in [0 0.0f 0.0]) :

  public defn xy (b:Box) -> Box2 :
    Box2(xy(lo(b)), xy(hi(b)))

  public defn xyz (b:Box) -> Box : b

  public defn empty? (b:Box) -> True|False :
    val d = dims(b)
    x(d) < x0 or y(d) < x0 or z(d) < x0

  public defn corners (b:Box) -> Tuple<BoxVec> :
    val [l, h] = [lo(b), hi(b)]
    [BoxVec(x(l), y(l), z(l)),
     BoxVec(x(l), y(l), z(h)), 
     BoxVec(x(l), y(h), z(l)), 
     BoxVec(x(l), y(h), z(h)), 
     BoxVec(x(h), y(l), z(l)), 
     BoxVec(x(h), y(l), z(h)),
     BoxVec(x(h), y(h), z(l)), 
     BoxVec(x(h), y(h), z(h))]

  public defn intersects? (b0:Box, b1:Box) -> True|False :
    not ((x(hi(b0)) < x(lo(b1)) or x(lo(b0)) > x(hi(b1))) or
         (y(hi(b0)) < y(lo(b1)) or y(lo(b0)) > y(hi(b1))) or
         (z(hi(b0)) < z(lo(b1)) or z(lo(b0)) > z(hi(b1))))

public defn times (mat:Mat44f, b:Box3f) -> Box3f :
  reduce(union, map(Box3f{ mat * _ }, corners(b)))

;;; MAT

public lostanza deftype Mat44f <: Array<Float> & Geom & Equalable :
  m00: float
  m01: float
  m02: float
  m03: float
  m10: float
  m11: float
  m12: float
  m13: float
  m20: float
  m21: float
  m22: float
  m23: float
  m30: float
  m31: float
  m32: float
  m33: float

public lostanza defn Mat44f (m00:ref<Float>,m01:ref<Float>,m02:ref<Float>,m03:ref<Float>,
                             m10:ref<Float>,m11:ref<Float>,m12:ref<Float>,m13:ref<Float>,
                             m20:ref<Float>,m21:ref<Float>,m22:ref<Float>,m23:ref<Float>,
                             m30:ref<Float>,m31:ref<Float>,m32:ref<Float>,m33:ref<Float>) -> ref<Mat44f> :
  return new Mat44f{m00.value,m01.value,m02.value,m03.value,m10.value,m11.value,m12.value,m13.value,
                    m20.value,m21.value,m22.value,m23.value,m30.value,m31.value,m32.value,m33.value}

public defn Mat44f (m:Mat44f) -> Mat44f :
  Mat44f(m[0, 0], m[0, 1], m[0, 2], m[0, 3],
         m[1, 0], m[1, 1], m[1, 2], m[1, 3], 
         m[2, 0], m[2, 1], m[2, 2], m[2, 3], 
         m[3, 0], m[3, 1], m[3, 2], m[3, 3])

lostanza defn mat44f-get (m:ref<Mat44f>, i:ref<Int>) -> ref<Float> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, new Int{16})
  return new Float{addr!(m.m00)[i.value]}

lostanza defn mat44f-set (m:ref<Mat44f>, i:ref<Int>, x:ref<Float>) -> ref<False> :
  #if-not-defined(OPTIMIZE) :
     ensure-index-in-bounds(i, new Int{16})
  addr!(m.m00)[i.value] = x.value
  return false

defmethod equal? (m1:Mat44f, m2:Mat44f) :
  label<True|False> return:
    for i in 0 to 4 do :
      for j in 0 to 4 do :
        if m1[i, j] != m2[i, j] : return(false)
    true

defmethod get (a:Mat44f, i:Int) -> Float : mat44f-get(a, i)
defmethod set (a:Mat44f, i:Int, c:Float) -> False : mat44f-set(a, i, c)
defmethod length (a:Mat44f) -> Int : 16

public defn get (m:Mat44f, x:Int, y:Int) -> Float :
  m[x * 4 + y]

public defn set (m:Mat44f, x:Int, y:Int, v:Float) -> False :
  m[x * 4 + y] = v

defmethod print (o:OutputStream, m:Mat44f) :
  print(o, "MAT(")
  for (i in 0 to 16) do :
     if i > 0 : print(o, ",")
     print(o, m[i])
  print-all(o, ")")

public defn gj-inverse (m:Mat44f) -> Mat44f :
  label<Mat44f> return :
    val s = id-mat44f()
    val t = Mat44f(m)
    for i in 0 to 3 do :
      var pivot = i
      var pivot-size:Float = t[i, i]
      if pivot-size < 0.0f :
        pivot-size = (- pivot-size)
      for j in (i + 1) to 4 do :
        var tmp:Float = t[j, i]
        if tmp < 0.0f :
          tmp = (- tmp)
        if tmp > pivot-size :
          pivot = j
          pivot-size = tmp
        if pivot-size == 0.0f :
          println(["SINGULAR"])
          ;; if singExc : throw SingMatrixExc ("Cannot invert singular matrix.")
          return(id-mat44f())
        if pivot != i :
          for j in 0 to 4 do :
            var tmp = t[i, j]
            t[i, j] = t[pivot, j]
            t[pivot, j] = tmp
            tmp = s[i, j]
            s[i, j] = s[pivot, j]
            s[pivot, j] = tmp

        for j in (i + 1) to 4 do :
          val f = t[j, i] / t[i, i]
          for k in 0 to 4 do :
            t[j, k] = t[j, k] - f * t[i, k]
            s[j, k] = s[j, k] - f * s[i, k]

    ;; Backward substitution

    for i in 3 through 0 by -1 do :
      val f = t[i, i]
      if f == 0.0f :
        println-all(["SINGULAR"])
        ;; if singExc : throw(SingMatrixExc ("Cannot invert singular matrix."))
        return(id-mat44f())
      for j in 0 to 4 do :
        t[i, j] = t[i, j] / f
        s[i, j] = s[i, j] / f
      for j in 0 to i do :
        val g = t[j, i]
        for k in 0 to 4 do :
          t[j, k] = t[j, k] - g * t[i, k]
          s[j, k] = s[j, k] - g * s[i, k]
    s

public defn inverse (m:Mat44f) -> Mat44f :
  label<Mat44f> return :
    if m[0, 3] != 0.0f or m[1, 3] != 0.0f or m[2, 3] != 0.0f or m[3, 3] != 1.0f :
      return(gj-inverse(m))
    val s = Mat44f(m[1, 1] * m[2, 2] - m[2, 1] * m[1, 2],
                  m[2, 1] * m[0, 2] - m[0, 1] * m[2, 2],
                  m[0, 1] * m[1, 2] - m[1, 1] * m[0, 2],
                  0.0f,

                  m[2, 0] * m[1, 2] - m[1, 0] * m[2, 2],
                  m[0, 0] * m[2, 2] - m[2, 0] * m[0, 2],
                  m[1, 0] * m[0, 2] - m[0, 0] * m[1, 2],
                  0.0f,

                  m[1, 0] * m[2, 1] - m[2, 0] * m[1, 1],
                  m[2, 0] * m[0, 1] - m[0, 0] * m[2, 1],
                  m[0, 0] * m[1, 1] - m[1, 0] * m[0, 1],
                  0.0f,

                  0.0f,
                  0.0f,
                  0.0f,
                  1.0f)
     val r = m[0, 0] * s[0, 0] + m[0, 1] * s[1, 0] + m[0, 2] * s[2, 0]
     if (abs(r) >= 1.0f) :
       for i in 0 to 3 do :
         for j in 0 to 3 do :
           s[i, j] = s[i, j] / r
     else :
       val mr = abs(r) / FLOAT-MIN ;; smallest
       for i in 0 to 3 do :
         for j in 0 to 3 do :
           if mr > abs(s[i, j]) :
             s[i, j] = s[i, j] / r
           else :
             println-all(["SINGULAR " m])
             ;; if singExc : throw(SingMatrixExc ("Cannot invert singular matrix."))
             return(id-mat44f())
             
    s[3, 0] = (- m[3, 0]) * s[0, 0] - m[3, 1] * s[1, 0] - m[3, 2] * s[2, 0]
    s[3, 1] = (- m[3, 0]) * s[0, 1] - m[3, 1] * s[1, 1] - m[3, 2] * s[2, 1]
    s[3, 2] = (- m[3, 0]) * s[0, 2] - m[3, 1] * s[1, 2] - m[3, 2] * s[2, 2]

    s

public defn reflect-xy-mat44f () -> Mat44f :
  Mat44f( 0.0f,  1.0f,  0.0f,  0.0f,
          1.0f,  0.0f,  0.0f,  0.0f,
          0.0f,  0.0f,  1.0f,  0.0f,
          0.0f,  0.0f,  0.0f,  1.0f)
 
public defn reflect-xz-mat44f () -> Mat44f :
  Mat44f( 0.0f,  0.0f,  1.0f,  0.0f,
          0.0f,  1.0f,  0.0f,  0.0f,
          1.0f,  0.0f,  0.0f,  0.0f,
          0.0f,  0.0f,  0.0f,  1.0f)
 
public defn reflect-yz-mat44f () -> Mat44f :
  Mat44f( 1.0f,  0.0f,  0.0f,  0.0f,
          0.0f,  0.0f,  1.0f,  0.0f,
          0.0f,  1.0f,  0.0f,  0.0f,
          0.0f,  0.0f,  0.0f,  1.0f)
 
public defn shear-x-y-mat44f (ymin:Float, ymax:Float, dx0:Float, dx1:Float) -> Mat44f :
  ;; TODO
  id-mat44f()
 
public defn id-mat44f () -> Mat44f : mag-mat44f(1.0f)

public defn mag-mat44f (s:Float) -> Mat44f :
  Mat44f(   s, 0.0f, 0.0f, 0.0f,
         0.0f,    s, 0.0f, 0.0f,
         0.0f, 0.0f,    s, 0.0f,
         0.0f, 0.0f, 0.0f, 1.0f)
 
public defn mag-mat44f (s:V3f) -> Mat44f :
  Mat44f(x(s), 0.0f, 0.0f, 0.0f,
         0.0f, y(s), 0.0f, 0.0f,
         0.0f, 0.0f, z(s), 0.0f,
         0.0f, 0.0f, 0.0f, 1.0f)

public defn mov-mat44f (t:V3f) -> Mat44f :
  Mat44f( 1.0f, 0.0f, 0.0f, 0.0f,
          0.0f, 1.0f, 0.0f, 0.0f,
          0.0f, 0.0f, 1.0f, 0.0f,
          t[0], t[1], t[2], 1.0f)

public defn rot-mat44f (r:V3f) -> Mat44f :
  val cos_rz = cos(r[2])
  val cos_ry = cos(r[1])
  val cos_rx = cos(r[0])

  val sin_rz = sin(r[2])
  val sin_ry = sin(r[1])
  val sin_rx = sin(r[0])

  val m00 = cos_rz * cos_ry
  val m01 = sin_rz * cos_ry
  val m02 = (- sin_ry)
  val m10 = (- sin_rz) * cos_rx + cos_rz * sin_ry * sin_rx
  val m11 = cos_rz * cos_rx + sin_rz * sin_ry * sin_rx
  val m12 = cos_ry * sin_rx
  val m20 = (- sin_rz) * (- sin_rx) + cos_rz * sin_ry * cos_rx
  val m21 = cos_rz * (- sin_rx) + sin_rz * sin_ry * cos_rx
  val m22 = cos_ry * cos_rx

  Mat44f( m00,  m01,  m02, 0.0f,
         m10,  m11,  m12, 0.0f,
         m20,  m21,  m22, 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f)

public defn rot-mat44f (r:V3f, a:Float) -> Mat44f :
  val u = normalize(r)
  val s = sin(a)
  val c = cos(a)

  val m00 = u[0] * u[0] * (1.0f - c) + c
  val m01 = u[1] * u[0] * (1.0f - c) + u[2] * s
  val m02 = u[2] * u[0] * (1.0f - c) - u[1] * s

  val m10 = u[0] * u[1] * (1.0f - c) - u[2] * s
  val m11 = u[1] * u[1] * (1.0f - c) + c
  val m12 = u[2] * u[1] * (1.0f - c) + u[0] * s

  val m20 = u[0] * u[2] * (1.0f - c) - u[1] * s
  val m21 = u[1] * u[2] * (1.0f - c) + u[0] * s
  val m22 = u[2] * u[2] * (1.0f - c) + c

  Mat44f( m00,  m01,  m02, 0.0f,
         m10,  m11,  m12, 0.0f,
         m20,  m21,  m22, 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f)

public defn rot2-mat44f (src:V3f, dst:V3f) -> Mat44f :
  val a = atan2(y(dst), x(dst)) - atan2(y(src), x(src))
  val [c, s] = [cos(a), sin(a)]
  Mat44f(    c    s 0.0f 0.0f
        (- s)    c 0.0f 0.0f
         0.0f 0.0f 1.0f 0.0f
         0.0f 0.0f 0.0f 1.0f)

public defn times (m:Mat44f, v:V3f) -> V3f :
  val px = x(v) * m[0,0] + y(v) * m[1,0] + z(v) * m[2,0] + m[3,0]
  val py = x(v) * m[0,1] + y(v) * m[1,1] + z(v) * m[2,1] + m[3,1]
  val pz = x(v) * m[0,2] + y(v) * m[1,2] + z(v) * m[2,2] + m[3,2]
  val pw = x(v) * m[0,3] + y(v) * m[1,3] + z(v) * m[2,3] + m[3,3]
  V3f(px / pw, py / pw, pz / pw)

public defn times (m:Mat44f, v:V2f) -> V2f :
  val px = x(v) * m[0,0] + y(v) * m[1,0] + m[3,0]
  val py = x(v) * m[0,1] + y(v) * m[1,1] + m[3,1]
  val pw = x(v) * m[0,3] + y(v) * m[1,3] + m[3,3]
  V2f(px / pw, py / pw)

public defn times (a:Mat44f, b:Mat44f) -> Mat44f :
  val res = id-mat44f()
  for i in 0 to 4 do :
    for j in 0 to 4 do :
      var sum: Float = 0.0f
      for k in 0 to 4 do :
        sum = sum + a[i,k] * b[k,j]
      res[i, j] = sum
  res

;;; HALF -- PLANE

public defstruct Half :
  normal:   V3f
  distance: Float

public defmethod print (o:OutputStream, g:Half) :
  print-all(o, ["half(" normal(g) "," distance(g) ")"])

public defn half (x:Float, y:Float, z:Float, d:Float) -> Half :
  Half(V3f(x, y, z), d)

public defn half (v:V3f, d:Float) -> Half :
  Half(v, d)

public defn half (p1:V3f, p2:V3f, p3:V3f) -> Half :
  val normal = normalize((p2 - p1) % (p3 - p1))
  val distance = dot(normal, p1)
  Half(normal, distance)

;; defn times (g:Half, m:Mat44f) -> Half :
;;   var dir1:V3f       = V3f(1.0f, 0.0f, 0.0f) % normal(g)
;;   var dir1-len:Float = dot(dir1, dir1)
;;   var tmp:V3f        = V3f(0.0f, 1.0f, 0.0f) % normal(g)
;;   var tmp-len:Float  = dot(tmp, tmp)
;;   if tmp-len > dir1-len :
;;     dir1     = tmp
;;     dir1-len = tmp-len
;;   tmp     = V3f(0.0f,0.0f, 1.0f) % normal(g)
;;   tmp-len = dot(tmp, tmp)
;;   if tmp-len > dir1-len :
;;     dir1     = tmp
;;   val dir2  = dir1 % normal(g)
;;   val point = distance(g) * normal(g)
;;   half(point * m, (point + dir2) * m, (point + dir1) * m)

public defn distance-to (plane:Half, point:V3f) -> Float :
  dot(point, normal(plane)) - distance(plane)

public defn level (g:Half, point:V3f) -> Float :
  (- distance-to(g, point))

;;; LINE

public defstruct Line <: Geom :
  pos: V3f
  dir: V3f

public defn closest-point-to (l:Line, point:V3f) -> V3f :
  dot((point - pos(l)), dir(l)) * dir(l) + pos(l)

public defn line-of (p0:V3f, p1:V3f) -> Line :
  Line(p0, normalize(p1 - p0))

;; public defn extrude (p0:V3f, p1:V3f) -> Half :
;;   val line   = line-of(p0, p1)
;;   val normal = V3f(y(dir(line)), (- x(dir(line))))
;;   val pt     = closest-point-to(line, V3f(0.0f, 0.0f))
;;   val align  = dot(normal, normalize(pt))
;;   ;; println-all(["CLOSEST POINT TO " x(pt) "," y(pt) " NORMAL " x(normal) "," y(normal) " ALIGN " align])
;;   Half(normal, (if align > 0.0f : 1.0f else : -1.0f) * len(pt))

public defstruct ImplicitLine :
  a : Float
  b : Float
  c : Float

public defn ImplicitLine (p:V2f, q:V2f) :
  ImplicitLine(y(q) - y(p), x(p) - x(q), x(q) * y(p) - y(q) * x(p))

public defn inside? (l:ImplicitLine, p:V2f) -> True|False :
  (a(l) * x(p) + b(l) * y(p) + c(l)) < 0.0f

public defstruct Triangle :
  points : Tuple<V2f>
  lines : Tuple<ImplicitLine>

defmethod print (o:OutputStream, t:Triangle) :
  print(o, "Triangle(%_)" % [points(t)])

public defn Triangle (ipts:Tuple<V2f>) :
  val order = xyz(ipts[1] - ipts[0]) % xyz(ipts[2] - ipts[0])
  val pts = ipts when z(order) >= 0.0f else [ ipts[0] ipts[2] ipts[1] ]
  val lines = for i in 0 to 3 seq : ImplicitLine(pts[i], pts[(i + 1) % 3])
  Triangle(pts, to-tuple $ lines)

public defn inside? (l:Triangle, p:V2f) -> True|False :
  inside?(lines(l)[0], p) and inside?(lines(l)[1], p) and inside?(lines(l)[2], p)

public defn bounds (t:Triangle) : reduce(union, seq(Box2f, points(t)))

;;; CONTOUR

public defstruct Contour <: Geom :
  points: Tuple<V2f>

defmethod print (o:OutputStream, c:Contour) :
  print("Contour(%,)" % [points(c)])

defn do-print-svg (s:OutputStream, contour:Contour) :
  print(s, "<path d=\"")
  for (p in points(contour), i in 0 to false) do :  
    print-all(s, [" " ("M" when i == 0 else "L") " " x(p) " " y(p)])
  print(s, " Z \" fill=\"none\" stroke=\"red\" stroke-width=\"0.02\"/>")

public defn circle-n (d:Float, n:Int) -> Polygon :
  val r = 0.5f * d
  val points = 
    for i in 0 to n seq :
      val a = to-float(i) * 2.0f * PI-F / to-float(n)
      V2f(r * sin(a), r * cos(a))
  to-polygon(Contour(to-tuple(points)))

public defn to-polygon (c:Contour) -> Polygon :
  Polygon([c])

public defn times (mat:Mat44f, p:Contour) -> Contour :
  Contour(for p in points(p) map : mat * p)

public defn plus (p:Contour, off:V2f) -> Contour :
  Contour(for p in points(p) map : p + off)

public defn minus (p:Contour, off:V2f) -> Contour :
  Contour(for p in points(p) map : p - off)

public defn segments (contour:Contour) -> Seq<[V2f, V2f]> :
  val pts = points(contour)
  for i in 0 to length(pts) seq :
    [pts[i], pts[(i + 1) % length(pts)]]

;; ;;; STROKE
;; 
;; public defstruct Stroke <: Geom :
;;   points: Tuple<V2f>
;; 
;; defmethod print (o:OutputStream, c:Stroke) :
;;   print("Stroke(%,)" % [points(c)])
;; 
;; public defn times (mat:Mat44f, p:Stroke) -> Stroke :
;;   Stroke(for p in points(p) map : mat * p)

;;; POLYGON

public defstruct Polygon <: Geom :
  contours: Tuple<Contour>

public defn to-v2f (vals:Seqable<Float>) -> V2f :
  val elts = to-tuple $ vals
  V2f(elts[0], elts[1])
  
public defn Polygon (cs:Seqable<Seqable<V2f>>) -> Polygon :
  Polygon(to-tuple $ seq(Contour, seq(to-tuple, cs)))

public defn points (p:Polygon) -> Tuple<V2f> :
  to-tuple $ cat-all(for c in contours(p) seq : points(c))

defmethod print (o:OutputStream, c:Polygon) :
  print("Polygon(%,)" % [contours(c)])

public defn times (mat:Mat44f, p:Polygon) -> Polygon :
  Polygon(for c in contours(p) map : mat * c)

public defn plus (p:Polygon, off:V2f) -> Polygon :
  Polygon(for c in contours(p) map : c + off)

public defn minus (p:Polygon, off:V2f) -> Polygon :
  Polygon(for c in contours(p) map : c - off)

public defn segments (polygon:Polygon) -> Seq<[V2f, V2f]> :
  cat-all(for c in contours(polygon) seq : segments(c))

defn do-print-svg (s:OutputStream, polygon:Polygon, bounds:Box2f) :
  println-all(s, ["<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>"])
  println-all(s, ["<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\""])
  println-all(s, [" width=\"" x(dims(bounds)) "\" height=\"" y(dims(bounds)) "\" id=\"cons\">"])
  val poly = polygon - lo(bounds)
  for c in contours(poly) do :
    do-print-svg(s, c)
  println(s, "\n</svg>")

public defn svg (polygon:Polygon, filename:String, bounds:Box2f) :
  val s = FileOutputStream(filename)
  try : do-print-svg(s, polygon, bounds)
  finally : close(s)

;;; POLYLINE

#for (Prim in [Float Float]
      Vec in [V2f V3f]
      PolyLine in [PolyLine2f PolyLine3f]
      Box in [Box2f Box3f]
      neg-inf-box in [neg-inf-box2f neg-inf-box3f]
      PolyLineName in ["PolyLine2f" "PolyLine3f"]) :

  public defstruct PolyLine <: Geom :
    ;; strokes: Tuple<Stroke>
    strokes: Tuple<Tuple<Vec>>

  defmethod print (o:OutputStream, c:PolyLine) :
    print("%_(%,)" % [PolyLineName strokes(c)])

  public defn bbox (p:PolyLine) -> Box :
    if length(strokes(p)) == 0 :
      Box(Vec(0.0f, 0.0f), Vec(0.0f, 0.0f))
    else :
      val boxes = seq(reduce{union, neg-inf-box(), seq(Box, _)}, strokes(p))
      reduce(union, neg-inf-box(), boxes)

  public defn times (mat:Mat44f, p:PolyLine) -> PolyLine :
    PolyLine(for s in strokes(p) map : for v in s map : mat * v)

  public defn center (p:PolyLine) -> PolyLine :
    mov-mat44f(xyz((- center(bbox(p))))) * p

  public defn center-x (p:PolyLine) -> PolyLine :
    mov-mat44f(xyz(Vec((- x(center(bbox(p)))), 0.0f))) * p

  public defn mag (p:PolyLine, fac:Vec) -> PolyLine :
    mag-mat44f(xyz(fac)) * p

  public defn offset (p:PolyLine, off:Vec) -> PolyLine :
    mov-mat44f(xyz(off)) * p

  public defn segments (polyline:PolyLine) -> Seq<[Vec, Vec]> :
    generate<[Vec, Vec]> :
      for s in strokes(polyline) do :
        for i in 0 to (length(s) - 1) do :
          yield([s[i], s[i + 1]])

;;; MESH
 
public defstruct Mesh <: Geom :
  vertices: Tuple<V3f>
  faces:    Tuple<V3i>

defmethod print (o:OutputStream, m:Mesh) :
  print-all(o, ["Mesh(" vertices(m) "," faces(m) ")"])

;; ;; public defn triangulate (p: Polygon) :
;; ;;   val vertices = Vector<V3f>()
;; ;;   val faces  = Vector<Int>()
;; ;; 
;; ;;   defn vertex-callback (index: Int) :
;; ;;     ;; println("Vertex Callback")
;; ;;     add(faces, index)
;; ;; 
;; ;;   defn combine-callback (x:Float, y:Float, z:Float) -> Int :
;; ;;     ;; println("Combine Callback")
;; ;;     add(vertices, V3f(x, y, z))
;; ;;     length(vertices) - 1
;; ;; 
;; ;;   val tess-ptr = call-c(triangulator_new, vertex-callback, combine-callback)
;; ;; 
;; ;;   call-c(triangulator_begin_polygon, tess-ptr)
;; ;;   for c in contours(p) do :
;; ;;     call-c(triangulator_begin_contour, tess-ptr)
;; ;;     for p in points(c) do :
;; ;;       add(vertices, p)
;; ;;       call-c(triangulator_vertex, tess-ptr, length(vertices) - 1, x(p), y(p), z(p))
;; ;;     call-c(triangulator_end_contour, tess-ptr)
;; ;;   call-c(triangulator_end_polygon, tess-ptr)
;; ;; 
;; ;;   Mesh(vertices, faces)

;;; QUAT

public defstruct Quat <: Geom & Equalable :
  w: Float
  v: V3f

public defn quat-from-axis (axis:V3f, rads:Float) -> Quat :
  val angle = rads / 2.0f
  val sin-angle = sin(angle)
  val n = normalize(axis)
  Quat(cos(angle), sin-angle * n)

val zero-quat = quat-from-axis(V3f(1.0f, 0.0f, 0.0f), 0.0f)

public defn zero? (q:Quat) : q == zero-quat

public defn Quat () : zero-quat

defmethod print (o:OutputStream, q:Quat) :
  print-all(o, ["Quat(" v(q) "," w(q) ")"])

defmethod equal? (q1:Quat, q2:Quat) :
  v(q1) == v(q2) and w(q1) == w(q2) 

public defn times (s:Float, q:Quat) -> Quat :
  Quat(s * w(q), s * v(q))

public defn divide (q:Quat, d:Float) -> Quat :
  Quat(w(q) / d, v(q) / d)

public defn x (q:Quat) -> Float : x(v(q))
public defn y (q:Quat) -> Float : y(v(q))
public defn z (q:Quat) -> Float : z(v(q))

public defn times (q1:Quat, q2:Quat) -> Quat :
  Quat(w(q1) * w(q2) - dot(v(q1), v(q2)), w(q1) * v(q2) + w(q2) * v(q1) + v(q1) % v(q2))

public defn dot (q1:Quat, q2:Quat) -> Float :
  dot(v(q1), v(q2)) + w(q1) * w(q2)

public defn conjugate (q:Quat) -> Quat :
  Quat(w(q), (- v(q)))

public defn negate (q:Quat) -> Quat :
  conjugate(q) / dot(q, q)

public defn magnitude (q:Quat) -> Float :
  sqrt(dot(q, q))

public defn normalize (q:Quat) -> Quat :
  q / magnitude(q)

val DELTA = 0.95f

public defn slerp (src:Quat, dst0:Quat, t:Float) -> Quat :
  val cosom0 = dot(src, dst0)
  val [cosom, dst] =
    if cosom0 < 0.0f :
      [(- cosom0), -1.0f * dst0]
    else :
      [cosom0, dst0]
  val [s0, s1] =
    if (1.0f - cosom) > DELTA :
      val omega = acos(cosom)
      val sinom = sin(omega)
      [sin((1.0f - t) * omega) / sinom, sin(t * omega) / sinom]
    else :
      [1.0f - t, t]
  Quat(s0 * w(src) + s1 * w(dst), s0 * v(src) + s1 * v(dst))

public defn quat-to-mat44f (q:Quat) -> Mat44f :
  val [ wx,  wy,  wz] = [w(q) * x(q), w(q) * y(q), w(q) * z(q)]
  val [ xx,  xy,  xz] = [x(q) * x(q), x(q) * y(q), x(q) * z(q)]
  val [ yy,  yz,  zz] = [y(q) * y(q), y(q) * z(q), z(q) * z(q)]
  val [m00, m01, m02] = [1.0f - 2.0f * (yy + zz),        2.0f * (xy - wz),        2.0f * (xz + wy)]
  val [m10, m11, m12] = [       2.0f * (xy + wz), 1.0f - 2.0f * (xx + zz),        2.0f * (yz - wx)]
  val [m20, m21, m22] = [       2.0f * (xz - wy),        2.0f * (yz + wx), 1.0f - 2.0f * (xx + yy)]
  Mat44f( m00,  m01,  m02, 0.0f,
          m10,  m11,  m12, 0.0f,
          m20,  m21,  m22, 0.0f,
         0.0f, 0.0f, 0.0f, 1.0f)

;;; ARCBALL

val epsilon = 0.000001f

public defstruct ArcBall :
  st-vec: V3f with: (setter => st-vec-set)
  en-vec: V3f with: (setter => en-vec-set)
  adjust-width: Float with: (setter => adjust-width-set)
  adjust-height: Float with: (setter => adjust-height-set)
  quat : Quat with: (setter => set-quat)
  base-quat : Quat with: (setter => set-base-quat)
  rot : Mat44f with: (setter => set-rot)

public defn clone (ball:ArcBall) :
  ArcBall(adjust-width(ball), adjust-height(ball))
  
public defn set-bounds (a:ArcBall, new-width:Float, new-height:Float) :
  ;; adjust-width-set(a, 1.0f / ((new-width - 1.0f) * 0.5f))
  ;; adjust-height-set(a, 1.0f / ((new-width - 1.0f) * 0.5f))
  adjust-width-set(a, new-width)
  adjust-height-set(a, new-height)

defn clip (x:Float, mn:Float, mx:Float) -> Float :
  min(mx, max(mn, x))

public defn map-to-sphere (a:ArcBall, new-pt:V2f) -> V3f :
  ;; val pt = V2f(x(new-pt) * adjust-width(a) - 1.0f, 1.0f - (y(new-pt) * adjust-height(a)))
  val pt = V2f(clip((-(2.0f * x(new-pt) / adjust-width(a)  - 1.0f)), -1.0f, 1.0f),
               clip(  (2.0f * y(new-pt) / adjust-height(a) - 1.0f),  -1.0f, 1.0f))
  ;; println-all(["NEW-PT " new-pt " AW " adjust-width(a) " AH " adjust-height(a) " PT = " pt])
  val len2 = dot(pt, pt)
  val res = 
    if len2 > 1.0f :
      ;; (1.0f / sqrt(len2)) * pt
      ;; println("> 1.0f")
      val len  = sqrt(len2)
      val res  = V3f(x(pt), y(pt), 1.0f / len)
      val rlen = sqrt(len2 + z(res) * z(res))
      normalize(res / rlen)
    else :
      V3f(x(pt), y(pt), sqrt(1.0f - len2))
  ;; println-all(["RES = " res])
  res

public defn ArcBall (new-width:Float, new-height:Float) -> ArcBall :
  val res = ArcBall(V3f(0.0f, 0.0f, 0.0f), V3f(0.0f, 0.0f, 0.0f), 0.0f, 0.0f, Quat(), Quat(), id-mat44f())
  set-bounds(res, new-width, new-height)
  res

public defn click (a:ArcBall, new-pt:V2f) :
  ;; println-all(["CLICK " new-pt])
  st-vec-set(a, map-to-sphere(a, new-pt))
  set-quat(a, base-quat(a))

public defn reset! (a:ArcBall) :
  set-rot(a, id-mat44f())
  set-quat(a, Quat())
  set-base-quat(a, Quat())

public defn drag (a:ArcBall, new-pt:V2f) :
  ;; println-all(["DRAG  " new-pt])
  en-vec-set(a, map-to-sphere(a, new-pt))
  val perp = st-vec(a) % en-vec(a)
  if magnitude(perp) > epsilon :
    val q = normalize(Quat(dot(st-vec(a), en-vec(a)), perp))
    ;; set-quat(a, (- q) * base-quat(a))
    ;; set-quat(a, conjugate(q) * base-quat(a))
    ;; set-quat(a, base-quat(a) * conjugate(q))
    set-quat(a, base-quat(a) * q)
    set-rot(a, quat-to-mat44f(quat(a)))
    q
    
public defn complete-drag (a:ArcBall) :
 set-base-quat(a, quat(a))

public val MOV-AMOUNT = 2000.0f
public val MAG-SCALE  = 0.008f
public val MOV-SCALE  = 0.0001f

public defstruct Transformation :
  ball : ArcBall with: (setter => set-ball)
  mag : Float with: (setter => set-mag)
  mov : V2f with: (setter => set-mov)
  last-x : Float with: (setter => set-last-x)

public defn clone (xform:Transformation) :
  Transformation(clone(ball(xform)), mag(xform), V2f(0.0f, 0.0f), 0.0f)

public defn mov! (xform:Transformation, amount:V2f) :
  set-mov(xform, mov(xform) + MOV-SCALE * amount)

public defn reset! (t:Transformation) :
  reset!(ball(t))
  set-mov(t, V2f(0.0f, 0.0f))
  set-mag(t, 1.0f)
  set-last-x(t, 0.0f)
