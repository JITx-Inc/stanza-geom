defpackage geom:
  import core
  import math
  import collections

public defstruct Mat44 :
  elts: Array<Float>

public defn mat44 (m00:Float,m01:Float,m02:Float,m03:Float,
                   m10:Float,m11:Float,m12:Float,m13:Float,
                   m20:Float,m21:Float,m22:Float,m23:Float,
                   m30:Float,m31:Float,m32:Float,m33:Float) -> Mat44 :
  Mat44(to-array<Float>([m00,m01,m02,m03,m10,m11,m12,m13,m20,m21,m22,m23,m30,m31,m32,m33]))

defmethod print (o:OutputStream, m:Mat44) :
  print(o, "MAT(")
  for (e in elts(m), i in 0 to false) do :
     if i > 0 : print(o, ",")
     print(o, e)
  print-all(o, ")")

public defn get (m:Mat44, x:Int, y:Int) -> Float :
  elts(m)[x * 4 + y]

public defn set (m:Mat44, x:Int, y:Int, v:Float) -> False :
  elts(m)[x * 4 + y] = v

public defn mag-mat44 (s:Float) -> Mat44 :
  mat44(   s, 0.0f, 0.0f, 0.0f,
        0.0f,    s, 0.0f, 0.0f,
        0.0f, 0.0f,    s, 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f)

public defn mag-mat44 (s:V3f) -> Mat44 :
  mat44(x(s), 0.0f, 0.0f, 0.0f,
        0.0f, y(s), 0.0f, 0.0f,
        0.0f, 0.0f, z(s), 0.0f,
        1.0f, 1.0f, 1.0f, 1.0f)

public defn mov-mat44 (t:V3f) -> Mat44 :
  mat44( 1.0f, 0.0f, 0.0f, 0.0f,
         0.0f, 1.0f, 0.0f, 0.0f,
         0.0f, 0.0f, 1.0f, 0.0f,
         t[0], t[1], t[2], 1.0f)

public defn rot-mat44 (r:V3f) -> Mat44 :
  val cos_rz = cos(r[2])
  val cos_ry = cos(r[1])
  val cos_rx = cos(r[0])

  val sin_rz = sin(r[2])
  val sin_ry = sin(r[1])
  val sin_rx = sin(r[0])

  val m00 = cos_rz * cos_ry
  val m01 = sin_rz * cos_ry
  val m02 = (- sin_ry)
  val m10 = (- sin_rz) * cos_rx + cos_rz * sin_ry * sin_rx
  val m11 = cos_rz * cos_rx + sin_rz * sin_ry * sin_rx
  val m12 = cos_ry * sin_rx
  val m20 = (- sin_rz) * (- sin_rx) + cos_rz * sin_ry * cos_rx
  val m21 = cos_rz * (- sin_rx) + sin_rz * sin_ry * cos_rx
  val m22 = cos_ry * cos_rx

  mat44( m00,  m01,  m02, 0.0f,
         m10,  m11,  m12, 0.0f,
         m20,  m21,  m22, 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f)

public defn rot-mat44 (r:V3f, a:Float) -> Mat44 :
  val u = normalize(r)
  val s = sin(a)
  val c = cos(a)

  val m00 = u[0] * u[0] * (1.0f - c) + c
  val m01 = u[0] * u[1] * (1.0f - c) + u[2] * s
  val m02 = u[0] * u[2] * (1.0f - c) - u[1] * s

  val m10 = u[0] * u[1] * (1.0f - c) - u[2] * s
  val m11 = u[1] * u[1] * (1.0f - c) + c
  val m12 = u[1] * u[2] * (1.0f - c) + u[0] * s

  val m20 = u[0] * u[2] * (1.0f - c) + u[1] * s
  val m21 = u[1] * u[2] * (1.0f - c) - u[0] * s
  val m22 = u[2] * u[2] * (1.0f - c) + c

  mat44( m00,  m01,  m02, 0.0f,
         m10,  m11,  m12, 0.0f,
         m20,  m21,  m22, 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f)

public defn times (v:V3f, m:Mat44) -> V3f :
  val px = x(v) * m[0,0] + y(v) * m[1,0] + z(v) * m[2,0] + m[3,0]
  val py = x(v) * m[0,1] + y(v) * m[1,1] + z(v) * m[2,1] + m[3,1]
  val pz = x(v) * m[0,2] + y(v) * m[1,2] + z(v) * m[2,2] + m[3,2]
  val pw = x(v) * m[0,3] + y(v) * m[1,3] + z(v) * m[2,3] + m[3,3]
  V3f(px / pw, py / pw, pz / pw)

public defn times (a:Mat44, b:Mat44) -> Mat44 :
  val res = mag-mat44(1.0f)
  for i in 0 to 4 do :
    for j in 0 to 4 do :
      var sum: Float = 0.0f
      for k in 0 to 4 do :
        sum = sum + a[i,k] * b[k,j]
      res[i, j] = sum
  res

