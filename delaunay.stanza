defpackage delaunay :
  import core
  import collections
  import geom
  import utils

val vertex-ids = to-seq(0 to false)

public defstruct Vertex <: Equalable&Hashable :
  id : Int
  value : V2f
  #edge : False|Edge with: ( setter => set-edge )

public defn edge (v:Vertex) : #edge(v) as Edge

public defn Vertex (v:V2f) : Vertex(next(vertex-ids), v, false)

defmethod print (o:OutputStream, v:Vertex) :
  print(o, "VERTEX(ID %_, VALUE %_)" % [id(v), value(v)])

defmethod equal? (a:Vertex, b:Vertex) : id(a) == id(b)
defmethod hash (a:Vertex) : hash(id(a))

val edge-ids = to-seq(0 to false)

public defstruct Edge <: Equalable&Hashable :
  id : Int
  num : Int
  #next : False|Edge with: ( setter => set-next )
  #data : False|Vertex with: ( setter => #set-data )
  quad : QuadEdge    with: ( setter => set-quad )

defn set-data (e:Edge, v:Vertex) :
  #set-data(e, v)
  set-edge(v, e)

defmethod print (o:OutputStream, e:Edge) :
  print(o, "EDGE(ID %_, NUM %_, NEXT %_, DATA %_, DEST %_)" % [id(e), num(e), id(next(e)), #data(e), dest(e)])

public defn next (e:Edge) : #next(e) as Edge
public defn data (e:Edge) : #data(e) as Vertex

defn Edge () :
  edges(QuadEdge())[0]

defn Edge (a:Vertex, b:Vertex) :
  val e = edges(QuadEdge())[0]
  set-end-points(e, a, b)
  e

defmethod equal? (a:Edge, b:Edge) : id(a) == id(b)
defmethod hash (a:Edge) : hash(id(a))

public defn length (e:Edge) -> Float : magnitude(value(org(e)) - value(dest(e)))

val quad-edge-ids = to-seq(0 to false)

public defstruct QuadEdge <: Equalable&Hashable :
  id : Int
  constrained? : True|False with: ( setter => set-constrained? )
  edges : Tuple<Edge> with: ( setter => set-edges )

defmethod equal? (a:QuadEdge, b:QuadEdge) : id(a) == id(b)
defmethod hash (a:QuadEdge) : hash(id(a))

defmethod print (o:OutputStream, q:QuadEdge) :
  print(o, "QUADeDGE(ID %_, EDGES %,_)" % [id(q), edges(q)])

defn QuadEdge () :
  val q = QuadEdge(next(quad-edge-ids), false, [])
  val es = to-tuple $ for i in 0 to 4 seq :
    Edge(next(edge-ids), i, false, false, q)
  set-edges(q, es)
  set-next(es[0], es[0])
  set-next(es[1], es[3])
  set-next(es[2], es[2])
  set-next(es[3], es[1])
  q

public defn edges (s:Subdivision) -> Seqable<Edge> :
  edges(starting-edge(s))

defn set-not-exists?<?T> (h:HashSet<?T>, e:?T) -> True|False :
  if h[e] :
    false
  else :
    add(h, e)
    true

public defn edges (i:Edge) -> Seqable<Edge> :
  generate<Edge> :
    val visited? = HashSet<Edge>()
    let loop (e:Edge = i) :
      if set-not-exists?(visited?, e) :
        yield(e)
        loop(onext(e))
        loop(oprev(e))
        loop(dnext(e))
        loop(dprev(e))

public defn quad-edges (i:Edge) -> Seqable<QuadEdge> :
  seq(quad, unique(quad, edges(i)))

public defn dump (s:Subdivision) :
  println("DUMP")
  for e in edges(s) do :
    println("  %_" % [e])

public defn rot (e:Edge) :
  edges(quad(e))[num(e) + 1] when num(e) < 3 else edges(quad(e))[num(e) - 3]

public defn inv-rot (e:Edge) : 
  edges(quad(e))[num(e) - 1] when num(e) > 0 else edges(quad(e))[num(e) + 3]
  
public defn sym (e:Edge) : 
  edges(quad(e))[num(e) + 2] when num(e) < 2 else edges(quad(e))[num(e) - 2]

public defn onext (e:Edge) :
  next $ e

public defn oprev (e:Edge) :
  rot $ onext $ rot $ e

public defn dnext (e:Edge) :
  sym $ onext $ sym $ e

public defn dprev (e:Edge) :
  inv-rot $ onext $ inv-rot $ e

public defn lnext (e:Edge) :
  rot $ onext $ inv-rot $ e

public defn edges-of (ie:Edge, next:Edge -> Edge) -> Seq<Edge> :
  generate<Edge> :
    let loop (e:Edge = ie) :
      yield(e)
      val ne = next(e)
      if ne != ie : loop(ne)

public defn face-edges (ie:Edge) : edges-of(ie, lnext)
public defn face-neighbors (ie:Edge) -> Seq<Edge> :
  for e in seq(sym, edges-of(ie, lnext)) filter : e != false 
public defn origin-edges (ie:Edge) : edges-of(ie, onext)

public defn lprev (e:Edge) :
  sym $ onext $ e

public defn rnext (e:Edge) :
  inv-rot $ onext $ rot $ e

public defn rprev (e:Edge) :
  onext $ sym $ e

public defn org (e:Edge) :
  data $ e

public defn dest (e:Edge) :
  data $ sym $ e

defn set-org (e:Edge, p:Vertex) :
  set-data(e, p)

defn set-dest (e:Edge, p:Vertex) :
  set-data(sym(e), p)

defn set-end-points (e:Edge, org:Vertex, dst:Vertex) :
  set-data(e,      org)
  set-data(sym(e), dst)

defn end-points (e:Edge) -> [Vertex, Vertex]:
  [data(e), data(sym(e))]

defn splice (a:Edge, b:Edge) :
  val alpha = rot $ onext $ a
  val beta  = rot $ onext $ b
  val t1 = onext $ b
  val t2 = onext $ a
  val t3 = onext $ beta
  val t4 = onext $ alpha
  set-next(a, t1)
  set-next(b, t2)
  set-next(alpha, t3)
  set-next(beta, t4)

defn delete-edge (e:Edge) :
  splice(e,      oprev(e))
  splice(sym(e), oprev(sym(e)))
  
defn delete-edge (s:Subdivision, e:Edge) :
  if starting-edge(s) == e :
    warning("Subdivision: attempting to delete starting edge")
    set-starting-edge(s, onext(e) when e != onext(e) else dnext(e))
  delete-edge(e)
  
public defstruct Subdivision :
  starting-edge : Edge with: ( setter => set-starting-edge )

defmethod print (o:OutputStream, s:Subdivision) :
  print(o, "SUBDIVISION(%_)" % [starting-edge(s)])

public defn Subdivision (a:V2f, b:V2f, c:V2f) :
  val [va, vb, vc] = [Vertex(a), Vertex(b), Vertex(c)]
  val ea = Edge()
  set-end-points(ea, va, vb)
  val eb = Edge()
  splice(sym(ea), eb)
  set-end-points(eb, vb, vc)
  val ec = Edge()
  splice(sym(eb), ec)
  set-end-points(ec, vc, va)
  splice(sym(ec), ea)
  Subdivision(ea)

public defn Subdivision (ivertices:Seqable<Vertex>) :
  val verts = to-tuple $ ivertices
  val points = to-tuple $ seq(value, verts)
  ;; println("POINTS %_" % [points])
  val bounds = reduce(bit-or, seq(Box2f, points))
  val dims = dims(bounds)
  val ctr = center(bounds)
  val radius = magnitude(dims)
  val poly = mov(xyz $ ctr, polygon-n(2.1f * radius, 3))
  val pts = vertices $ contours(poly)[0]
  ;; println("RADIUS %_ POLY %_" % [radius, poly])
  val sub = Subdivision(pts[0], pts[1], pts[2])
  ;; dump(sub)
  for vertex in verts do :
    ;; println("INSERTING %_" % [pt])
    constrained-insert-site(sub, vertex, 0.0f)
  sub

public defn Subdivision (ipoints:Seqable<V2f>) :
  Subdivision(seq(Vertex, ipoints))

defn connect (a:Edge, b:Edge) :
  val e = Edge()
  splice(e, lnext(a))
  splice(sym(e), b)
  set-end-points(e, dest(a), org(b))
  e

defn swap (e:Edge) :
  val a = oprev(e)
  val b = oprev(sym(e))
  splice(e,      a)
  splice(sym(e), b)
  splice(e,      lnext(a))
  splice(sym(e), lnext(b))
  set-end-points(e, dest(a), dest(b))

defn snap (x:V2f, a:V2f, b:V2f) -> V2f :
  if x == a :
    a
  else if x == b :
    b
  else :
    val t1 = dot(x - a, b - a)
    val t2 = dot(x - b, a - b)
    val t = max(t1, t2) / (t1 + t2)
    ((1.0f - t) * a + t * b) when (t1 > t2) else ((1.0f - t) * b + t * a)

defn split-edge (e:Edge, x:V2f) -> Vertex :
  val dt =
    if constrained?(quad(e)) :
      Vertex(snap(x, value(org(e)), value(dest(e))))
    else :
      Vertex(x)
  val t = lnext(e)
  splice(sym(e), t)
  set-end-points(e, org(e), dt)
  val ne = connect(e, t)
  if constrained?(quad(e)) :
    set-constrained?(quad(e), true)
  dt
    
defn warning (m:String) :
  println(m)
  false      

defn tri-area (a:V2f, b:V2f, c:V2f) -> Float :
  (x(b) - x(a)) * (y(c) - y(a)) - (y(b) - y(a)) * (x(c) - x(a))

defn in-circle (a:V2f, b:V2f, c:V2f, d:V2f) :
  (dot(a, a) * tri-area(b, c, d) -
   dot(b, b) * tri-area(a, c, d) +
   dot(c, c) * tri-area(a, b, d) -
   dot(d, d) * tri-area(a, b, c)) > 0.0f

defn circum-center (a:V2f, b:V2f, c:V2f) :
  val d1 = dot(b - a, c - a) 
  val d2 = dot(b - c, a - c) 
  val d3 = dot(a - b, c - b)
  val c1 = d2 * d3
  val c2 = d3 * d1
  val c3 = c1 * d2
  ((c2 + c3) * a + (c3 + c1) * c + (c1 + c2) * b) / (2.0f * (c1 + c2 + c3))

defn has-left-face (e:Edge) -> True|False :
  org(lprev(e)) == dest(lnext(e)) and left-of(value(org(lprev(e))), e)

defn has-right-face (e:Edge) -> True|False :
  has-left-face(sym(e))

defn intersect (e:Edge, l:ImplicitLine) :
  intersect(l, value(org(e)), value(dest(e)))

defn ccw (a:V2f, b:V2f, c:V2f) -> True|False :
  tri-area(a, b, c) > 0.0f

defn cw (a:V2f, b:V2f, c:V2f) -> True|False :
  tri-area(a, b, c) < 0.0f

defn right-of (x:V2f, e:Edge) -> True|False :
  ccw(x, value(dest(e)), value(org(e)))

defn left-of (x:V2f, e:Edge) -> True|False :
  cw(x, value(dest(e)), value(org(e)))

;; defn on-edge (x:V2f, e:Edge) -> True|False :
;;   val t1 = normalize(x - org(e)
;;   val t2 = normalize(x - dest(e))
;;   if t1 < EPS or t2 < EPS :
;;     true
;;   else :
;;     val t3 = normalize(org(e) - dest(e))
;;     if t1 > t3 or t2 > t3 :
;;       false
;;     else :
;;       val line = Line(org(e), dest(e))
;;       abs(eval(line, x)) < EPS

defn on-edge (p:V2f, e:Edge) -> True|False :
  val op = magnitude(p - value(org(e)))
  if op < EPS :
    true
  else :
    val pd = magnitude(p - value(dest(e)))
    if pd < EPS :
      true
    else :
      val od = magnitude(value(org(e)) - value(dest(e)))
      abs(od - (op + pd)) < EPS

defn locate (s:Subdivision, x:V2f) -> Edge :
  ;; println("LOCATE %_" % [x])
  let loop (e:Edge = starting-edge(s)) :
    ;; println("LOOP %_" % [e])
    if x == value(org(e)) or x == value(dest(e)) :
      e
    else if right-of(x, e) :
      ;; println("RIGHT OF")
      loop(sym(e))
    else if not right-of(x, onext(e)) :
      ;; println("NOT RIGHT OF ONEXT")
      loop(onext(e))
    else if not right-of(x, dprev(e)) :
      ;; println("NOT RIGHT OF DPREV")
      loop(dprev(e))
    else :
      e

defn fix-edge (e:Edge) :
  println("FIXING %_" % [e]) 
  if not constrained?(quad(e)) :
    val [f, g] = [oprev(e), dnext(e)]
    if in-circle(value(dest(e)), value(dest(onext(e))), value(org(e)), value(dest(f))) :
      println("SWAPPING %_" % [e])
      swap(e)
      println("SWAPPED  %_" % [e])
      fix-edge(f)
      fix-edge(g)

defn triangulate (init-first:Edge) :
  var first:Edge = init-first
  val last = lprev(first)
  
  while lnext(lnext(first)) != last : 
    let loop (e:Edge = lnext(first)) :
      var t1:Edge = first
      if e != last :
        val t2 = lnext(e)
        if not (t2 == last and t1 == first) :
          if left-of(value(dest(e)), t1) :
            if t1 == first :
              t1 = sym(connect(e, t1))
              first = t1
            else :
              t1 = sym(connect(e, t1))
            println("TRIANGULATE CONNECTING %_" % [t1])
            val [a, b] = [oprev(t1), dnext(t1)]
            fix-edge(a)
            fix-edge(b)
          else :
            t1 = e
          loop(t2)

  val [a, b] = [lnext(last), lprev(last)]
  fix-edge(a)
  fix-edge(b)
  fix-edge(last)

public defn insert-site (s:Subdivision, vx:Vertex) -> False|Edge :
  ;; println("INSERT-SITE %_" % [x])
  val x = value(vx)
  var e:Edge = locate(s, x)
  ;; println("FOUND %_" % [e])
  label<False|Edge> return:
    if x == value(org(e)) or x == value(dest(e)) :
      ;; println("POINT ALREADY IN")
      return(false)
    else if on-edge(x, e) :
      ;; println("ON EDGE")
      e = oprev(e)
      delete-edge(onext(e))
    ;; println("CONNECT")
    var base:Edge = Edge()
    set-end-points(base, org(e), vx)
    splice(base, e)
    set-starting-edge(s, base)
    ;; dump(s)
    let loop () :
      ;; println("BASE LOOP")
      base = connect(e, sym(base))
      ;; dump(s)
      e = oprev(base)
      loop() when lnext(e) != starting-edge(s)
    while true :
      ;; println("EXAMINE DELAUNAY CONDITION")
      val t = oprev(e)
      if right-of(value(dest(t)), e) and in-circle(value(org(e)), value(dest(t)), value(dest(e)), x) :
        ;; println("SWAP")
        swap(e)
        e = oprev(e)
      else if onext(e) == starting-edge(s) :
        ;; println("DONE")
        return(starting-edge(s))
      else :
        ;; println("POP")
        e = lprev(onext(e))

public defn coincide (a:V2f, b:V2f, dist:Float) -> True|False :
  val d = a - b
  if abs(x(d)) > dist or abs(y(d)) > dist :
    false
  else :
    dot(d, d) <= (dist * dist)

public defn constrained-insert-site (s:Subdivision, vx:Vertex, dist:Float) -> False|Edge :
  ;; println("INSERT-SITE %_" % [x])
  label<False|Edge> return :
    val x = value(vx)
    var e:Edge = locate(s, x)

    if coincide(x, value(org(e)), dist) :
      return(e)
    if coincide(x, value(dest(e)), dist) :
      return(sym(e))

    val has-left = has-left-face(e)
    val has-right = has-right-face(e)

    if not has-left and not has-right :
      warning("insert-site: edge does not have any face")
      return(false)

    val is-on-edge = on-edge(x, e)
    val inside-left  = has-left and (is-on-edge or left-of(x, e)) and
                       right-of(x, onext(e)) and right-of(x, dprev(e))
    val inside-right = has-right and (is-on-edge or right-of(x, e)) and
                       left-of(x, oprev(e)) and left-of(x, dnext(e))

    if not inside-left and not inside-right :
      warning("insert-site: point not in a face adjacent to edge")
      return(false)
    
    if inside-left and coincide(x, value(dest(onext(e))), dist) :
      return(lprev(e))

    if inside-right and coincide(x, value(dest(oprev(e))), dist) :
      return(dnext(e))

    ;; Now we know, x lies within the quadrilateral whose diagonal is e
    ;; (or a triangle, if e only has one adjacent face). We also know x
    ;; is not one of e's endpoints.

    if is-on-edge :
      val xx = snap(x, value(org(e)), value(dest(e)))
      if coincide(xx, value(org(e)), dist) :
        return(e)
      if coincide(xx, value(dest(e)), dist) :
        return(sym(e))

      if has-right and has-left :
        val a = oprev(e)
        val b = dnext(e)
        val c = lnext(e)
        val d = lprev(e)
        split-edge(e, x)
        connect(e, lprev(e))
        connect(oprev(e), sym(e))
        fix-edge(a)
        fix-edge(b)
        fix-edge(c)
        fix-edge(d)
      else :
        if has-right :
          e = sym(e)
        val c = lnext(e)
        val d = lprev(e)
        split-edge(e, x)
        connect(e, lprev(e))
        fix-edge(c)
        fix-edge(d)
      set-starting-edge(s, sym(e))
      return(starting-edge(s))
    
    ;; x is not on e, should be in face to the left of e
    if not inside-left :
      warning("insert-site: point is not to the left of edge")
      return(false)

    ;; x should be strictly inside the left face
    if on-edge(x, onext(e)) or on-edge(x, dprev(e)) :
      warning("insert-site: point is not strictly inside face")

    ;; Now, hopefully, x is strictly inside the left face of e,
    ;; so everything should proceed smoothly from this point on.

    val first = org(e)
    var base:Edge = Edge(org(e), Vertex(x))
    splice(base, e)
    ;; use this edge as the starting point next time:
    set-starting-edge(s, sym(base))
    let loop () :
      base = connect(e, sym(base))
      e = oprev(base)
      loop() when dprev(e) != starting-edge(s)

    ;; Examine suspect edges to ensure that the Delaunay condition is satisfied.
    while true :
      ;; println("EXAMINE DELAUNAY CONDITION")
      val t = oprev(e)
      if not constrained?(quad(e)) and
          in-circle(value(org(e)), value(dest(t)), value(dest(e)), x) :
        ;; println("SWAP")
        swap(e)
        e = oprev(e)
      else if lprev(e) == starting-edge(s) :
        ;; println("DONE")
        return(starting-edge(s))
      else :
        ;; println("POP")
        e = lprev(onext(e))

public defn insert-edge (s:Subdivision, a:Vertex, b:Vertex) :
  label<False> return:
    match(constrained-insert-site(s, a, 0.0f), constrained-insert-site(s, b, 0.0f)) :
      (start-ea:Edge, eb:Edge) :
        var aa:V2f = value(org(start-ea))
        var bb:V2f = value(org(eb))
        val starting-edge = start-ea
        var ea:Edge = locate(s, aa)
        if aa != value(org(ea)) :
          ea = sym(ea)
        var ab:ImplicitLine = ImplicitLine2(aa, bb)
        var dd:V2f = bb - aa
        val last = org(eb)
        while org(ea) != last :
          ;; set ea to first edge to the right of (or aligned with)
          ;; the segment (a, b) by moving ccw around the origin of ea:
          val t = ea
          let loop () :
            if on?(ab, value(dest(ea))) and dot(value(dest(ea)) - aa, dd) > 0.0f :
              false
            else if on?(ab, value(dest(onext(ea)))) and dot(value(dest(onext(ea))) - aa, dd) > 0.0f :
              ea = onext(ea)
              loop()
            else if not cw(value(dest(ea)), bb, aa) and cw(value(dest(onext(ea))), bb, aa) :
              false
            else :
              ea = onext(ea)
              if ea == t :
                warning("insert-edge: infinite loop")
                return(false)
              loop()

          ;; check to see if an edge is already there
          if on?(ab, value(dest(ea))) :
            println("EDGE %_ ALREADY THERE" % [ea])
            set-constrained?(quad(ea), true)
            aa = value(dest(ea))
            if aa == bb : return(false)
            ab = ImplicitLine(aa, bb)
            dd = bb - aa
            ea = onext(sym(ea))
          else :
            let loop (t:Edge = ea) :
              if on?(ab, value(dest(lnext(t)))) :
                if lnext(lnext(lnext(t))) == ea :
                  ;; edge is already there
                  println("EDGE %_ ALREADY THERE" % [lnext(lnext(t))])
                  set-constrained?(quad(lnext(lnext(t))), true)
                  ea = sym(lnext(t))
                else :
                  ;; need a new edge
                  val ne = connect(lnext(t), ea)
                  println("NEED NEW EDGE -- CONSTRAINING -- CONNECTING %_" % [ne])
                  set-constrained?(quad(ne), true)
                  ea = sym(lnext(t))
                  triangulate(lnext(ne))
                  triangulate(oprev(ne))
              else if left?(ab, value(dest(lnext(t)))) :
                ;; edges cross
                println("EDGES CROSS")
                if not constrained?(quad(lnext(t))) :
                  println("NOT CONSTRAINED -- DELETING EDGE -- %_" % [lnext(t)])
                  delete-edge(s, lnext(t))
                  loop(t)
                else :
                  ;; the crossing edge is also constrained
                  ;; compute and insert the intersection
                  val x = intersect(lnext(t), ab)
                  ;; split lnext(t) into two at x
                  split-edge(lnext(t), x)
                  println("CROSSING EDGE ALSO CONSTRAINED -- SPLITTING AT %_" % [x])
                  ;; connect to eh new vertex:
                  val ne = connect(lnext(t), ea)
                  set-constrained?(quad(ne), true)
                  ea = sym(lnext(t))
                  triangulate(lnext(ne))
                  triangulate(oprev(ne))
              else :
                loop(lnext(t))

      (fa, fb) :
        println("DIDN'T FIND %_ %_" % [fa, fb])
        false    
