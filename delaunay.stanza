defpackage delaunay :
  import core
  import collections
  import geom
  import utils

val vertex-ids = to-seq(0 to false)

public defstruct Vertex <: Equalable&Hashable :
  id : Int
  value : V2f
  #edge : False|Edge with: ( setter => set-edge )

public defn edge (v:Vertex) : #edge(v) as Edge

public defn Vertex (v:V2f) : Vertex(next(vertex-ids), v, false)

defmethod print (o:OutputStream, v:Vertex) :
  print(o, "VERTEX(ID %_, VALUE %_)" % [id(v), value(v)])

defmethod equal? (a:Vertex, b:Vertex) : id(a) == id(b)
defmethod hash (a:Vertex) : hash(id(a))

val edge-ids = to-seq(0 to false)

public defstruct Edge <: Equalable&Hashable :
  id : Int
  num : Int
  #next : False|Edge with: ( setter => set-next )
  #data : False|Vertex with: ( setter => #set-data )
  quad : QuadEdge    with: ( setter => set-quad )

defn set-data (e:Edge, v:Vertex) :
  #set-data(e, v)
  set-edge(v, e)

defmethod print (o:OutputStream, e:Edge) :
  print(o, "EDGE(ID %_, NUM %_, NEXT %_, DATA %_)" % [id(e), num(e), id(next(e)), #data(e)])

public defn next (e:Edge) : #next(e) as Edge
public defn data (e:Edge) : #data(e) as Vertex

defn Edge () :
  edges(QuadEdge())[0]

defmethod equal? (a:Edge, b:Edge) : id(a) == id(b)
defmethod hash (a:Edge) : hash(id(a))

public defn length (e:Edge) -> Float : magnitude(value(org(e)) - value(dest(e)))

val quad-edge-ids = to-seq(0 to false)

public defstruct QuadEdge <: Equalable&Hashable :
  id : Int
  edges : Tuple<Edge> with: ( setter => set-edges )

defmethod equal? (a:QuadEdge, b:QuadEdge) : id(a) == id(b)
defmethod hash (a:QuadEdge) : hash(id(a))

defmethod print (o:OutputStream, q:QuadEdge) :
  print(o, "QUADeDGE(ID %_, EDGES %,_)" % [id(q), edges(q)])

defn QuadEdge () :
  val q = QuadEdge(next(quad-edge-ids), [])
  val es = to-tuple $ for i in 0 to 4 seq :
    Edge(next(edge-ids), i, false, false, q)
  set-edges(q, es)
  set-next(es[0], es[0])
  set-next(es[1], es[3])
  set-next(es[2], es[2])
  set-next(es[3], es[1])
  q

public defn edges (s:Subdivision) -> Seqable<Edge> :
  edges(starting-edge(s))

defn set-not-exists?<?T> (h:HashSet<?T>, e:?T) -> True|False :
  if h[e] :
    false
  else :
    add(h, e)
    true

public defn edges (i:Edge) -> Seqable<Edge> :
  generate<Edge> :
    val visited? = HashSet<Edge>()
    let loop (e:Edge = i) :
      if set-not-exists?(visited?, e) :
        yield(e)
        loop(onext(e))
        loop(oprev(e))
        loop(dnext(e))
        loop(dprev(e))

public defn quad-edges (i:Edge) -> Seqable<QuadEdge> :
  seq(quad, unique(quad, edges(i)))

public defn dump (s:Subdivision) :
  println("DUMP")
  for e in edges(s) do :
    println("  %_" % [e])

public defn rot (e:Edge) :
  edges(quad(e))[num(e) + 1] when num(e) < 3 else edges(quad(e))[num(e) - 3]

public defn inv-rot (e:Edge) : 
  edges(quad(e))[num(e) - 1] when num(e) > 0 else edges(quad(e))[num(e) + 3]
  
public defn sym (e:Edge) : 
  edges(quad(e))[num(e) + 2] when num(e) < 2 else edges(quad(e))[num(e) - 2]

public defn onext (e:Edge) :
  next $ e

public defn oprev (e:Edge) :
  rot $ onext $ rot $ e

public defn dnext (e:Edge) :
  sym $ onext $ sym $ e

public defn dprev (e:Edge) :
  inv-rot $ onext $ inv-rot $ e

public defn lnext (e:Edge) :
  rot $ onext $ inv-rot $ e

public defn edges-of (ie:Edge, next:Edge -> Edge) -> Seq<Edge> :
  generate<Edge> :
    let loop (e:Edge = ie) :
      yield(e)
      val ne = next(e)
      if ne != ie : loop(ne)

public defn face-edges (ie:Edge) : edges-of(ie, lnext)
public defn face-neighbors (ie:Edge) -> Seq<Edge> :
  for e in seq(sym, edges-of(ie, lnext)) filter : e != false 
public defn origin-edges (ie:Edge) : edges-of(ie, onext)

public defn lprev (e:Edge) :
  sym $ onext $ e

public defn rnext (e:Edge) :
  inv-rot $ onext $ rot $ e

public defn rprev (e:Edge) :
  onext $ sym $ e

public defn org (e:Edge) :
  data $ e

public defn dest (e:Edge) :
  data $ sym $ e

defn set-org (e:Edge, p:Vertex) :
  set-data(e, p)

defn set-dest (e:Edge, p:Vertex) :
  set-data(sym(e), p)

defn set-end-points (e:Edge, org:Vertex, dst:Vertex) :
  set-data(e,      org)
  set-data(sym(e), dst)

defn end-points (e:Edge) -> [Vertex, Vertex]:
  [data(e), data(sym(e))]

defn splice (a:Edge, b:Edge) :
  val alpha = rot $ onext $ a
  val beta  = rot $ onext $ b
  val t1 = onext $ b
  val t2 = onext $ a
  val t3 = onext $ beta
  val t4 = onext $ alpha
  set-next(a, t1)
  set-next(b, t2)
  set-next(alpha, t3)
  set-next(beta, t4)

defn delete-edge (e:Edge) :
  splice(e,      oprev(e))
  splice(sym(e), oprev(sym(e)))
  
public defstruct Subdivision :
  starting-edge : Edge with: ( setter => set-starting-edge )

defmethod print (o:OutputStream, s:Subdivision) :
  print(o, "SUBDIVISION(%_)" % [starting-edge(s)])

public defn Subdivision (a:V2f, b:V2f, c:V2f) :
  val [va, vb, vc] = [Vertex(a), Vertex(b), Vertex(c)]
  val ea = Edge()
  set-end-points(ea, va, vb)
  val eb = Edge()
  splice(sym(ea), eb)
  set-end-points(eb, vb, vc)
  val ec = Edge()
  splice(sym(eb), ec)
  set-end-points(ec, vc, va)
  splice(sym(ec), ea)
  Subdivision(ea)

public defn Subdivision (ivertices:Seqable<Vertex>) :
  val verts = to-tuple $ ivertices
  val points = to-tuple $ seq(value, verts)
  ;; println("POINTS %_" % [points])
  val bounds = reduce(bit-or, seq(Box2f, points))
  val dims = dims(bounds)
  val ctr = center(bounds)
  val radius = magnitude(dims)
  val poly = mov(xyz $ ctr, polygon-n(2.1f * radius, 3))
  val pts = vertices $ contours(poly)[0]
  ;; println("RADIUS %_ POLY %_" % [radius, poly])
  val sub = Subdivision(pts[0], pts[1], pts[2])
  ;; dump(sub)
  for vertex in verts do :
    ;; println("INSERTING %_" % [pt])
    insert-site(sub, vertex)
  sub

public defn Subdivision (ipoints:Seqable<V2f>) :
  Subdivision(seq(Vertex, ipoints))

defn connect (a:Edge, b:Edge) :
  val e = Edge()
  splice(e, lnext(a))
  splice(sym(e), b)
  set-end-points(e, dest(a), org(b))
  e

defn swap (e:Edge) :
  val a = oprev(e)
  val b = oprev(sym(e))
  splice(e,      a)
  splice(sym(e), b)
  splice(e,      lnext(a))
  splice(sym(e), lnext(b))
  set-end-points(e, dest(a), dest(b))

defn tri-area (a:V2f, b:V2f, c:V2f) -> Float :
  (x(b) - x(a)) * (y(c) - y(a)) - (y(b) - y(a)) * (x(c) - x(a))

defn in-circle (a:V2f, b:V2f, c:V2f, d:V2f) :
  (dot(a, a) * tri-area(b, c, d) -
   dot(b, b) * tri-area(a, c, d) +
   dot(c, c) * tri-area(a, b, d) -
   dot(d, d) * tri-area(a, b, c)) > 0.0f

defn ccw (a:V2f, b:V2f, c:V2f) -> True|False :
  tri-area(a, b, c) > 0.0f

defn right-of (x:V2f, e:Edge) -> True|False :
  ccw(x, value(dest(e)), value(org(e)))

defn left-of (x:V2f, e:Edge) -> True|False :
  ccw(x, value(org(e)), value(dest(e)))

;; defn on-edge (x:V2f, e:Edge) -> True|False :
;;   val t1 = normalize(x - org(e)
;;   val t2 = normalize(x - dest(e))
;;   if t1 < EPS or t2 < EPS :
;;     true
;;   else :
;;     val t3 = normalize(org(e) - dest(e))
;;     if t1 > t3 or t2 > t3 :
;;       false
;;     else :
;;       val line = Line(org(e), dest(e))
;;       abs(eval(line, x)) < EPS

val EPS = 1.0e-6f

defn on-edge (p:V2f, e:Edge) -> True|False :
  val op = magnitude(p - value(org(e)))
  if op < EPS :
    true
  else :
    val pd = magnitude(p - value(dest(e)))
    if pd < EPS :
      true
    else :
      val od = magnitude(value(org(e)) - value(dest(e)))
      abs(od - (op + pd)) < EPS

defn locate (s:Subdivision, x:V2f) -> Edge :
  ;; println("LOCATE %_" % [x])
  let loop (e:Edge = starting-edge(s)) :
    ;; println("LOOP %_" % [e])
    if x == value(org(e)) or x == value(dest(e)) :
      e
    else if right-of(x, e) :
      ;; println("RIGHT OF")
      loop(sym(e))
    else if not right-of(x, onext(e)) :
      ;; println("NOT RIGHT OF ONEXT")
      loop(onext(e))
    else if not right-of(x, dprev(e)) :
      ;; println("NOT RIGHT OF DPREV")
      loop(dprev(e))
    else :
      e

public defn insert-site (s:Subdivision, vx:Vertex) :
  ;; println("INSERT-SITE %_" % [x])
  val x = value(vx)
  var e:Edge = locate(s, x)
  ;; println("FOUND %_" % [e])
  label<False> return:
    if x == value(org(e)) or x == value(dest(e)) :
      ;; println("POINT ALREADY IN")
      return(false)
    else if on-edge(x, e) :
      ;; println("ON EDGE")
      e = oprev(e)
      delete-edge(onext(e))
    ;; println("CONNECT")
    var base:Edge = Edge()
    set-end-points(base, org(e), vx)
    splice(base, e)
    set-starting-edge(s, base)
    ;; dump(s)
    let loop () :
      ;; println("BASE LOOP")
      base = connect(e, sym(base))
      ;; dump(s)
      e = oprev(base)
      loop() when lnext(e) != starting-edge(s)
    while true :
      ;; println("EXAMINE DELAUNAY CONDITION")
      val t = oprev(e)
      if right-of(value(dest(t)), e) and in-circle(value(org(e)), value(dest(t)), value(dest(e)), x) :
        ;; println("SWAP")
        swap(e)
        e = oprev(e)
      else if onext(e) == starting-edge(s) :
        ;; println("DONE")
        return(false)
      else :
        ;; println("POP")
        e = lprev(onext(e))
    
